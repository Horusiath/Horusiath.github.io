
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>Javascript a wzorce projektowe - Simple Solutions</title>
	<meta name="author" content="Bartosz Sypytkowski">

	
	<meta name="description" content="Javascript a Wzorce Projektowe Założę się, że wiele osób czytając ten tytuł puknie się w głowę. I owszem w wielu sytuacjach wzorce nie są niezbędne &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Simple Solutions" type="application/atom+xml">
	
	<link rel="canonical" href="http://bartoszsypytkowski.com/blog/2013/02/23/javascript-wzorce-projektowe/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
  
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-47294845-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><h1 id="profile-name"><a href="/">Bartosz Sypytkowski</a></h1>
<div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("b.sypytkowski@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:b.sypytkowski@gmail.com" title="Email">Email</a>
		
		
		
			<a class="google" href="https://plus.google.com/b.sypytkowski@gmail.com" rel="author" title="Google+">Google+</a>
		
		
			<a class="twitter" href="http://twitter.com/horusiath" title="Twitter">Twitter</a>
		
		
			<a class="github" href="https://github.com/horusiath" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		
		
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">Javascript a Wzorce Projektowe</h1>
	<div class="entry-content" itemprop="articleBody"><p>Założę się, że wiele osób czytając ten tytuł puknie się w głowę. I owszem w wielu sytuacjach wzorce nie są niezbędne do tworzenia przejrzystych i dobrze rozwijalnych skryptów. Do czasu. Dokładnie do momentu gdy nasz skrypt zaczyna mieć więcej niż kilkadziesiąt linijek.</p>

<p>W zależności od języka programowania, pisany przez nas kod może mieć mniejszą lub większą przejrzystość. Niektóre języki takie jak Haskel, są z natury bardzo klarowne i skupiają się na istocie rzeczy. Inne, jak właśnie Javascript, dają programiście olbrzymie możliwość zrobienia czegoś na pierdyliard sposobów, co nie oznacza, że każdy sposób jest poprawny. Jakby tego było mało, javascriptowe JITy są wstanie przełknąć nawet bardzo niezdarny kod. Dlatego właśnie dyscyplina samego programisty oraz stosowanie wzorców jest tym bardziej istotne.</p>

<p>O tradycyjnych wzorcach &ndash; strategiach, obserwatorach etc. &ndash; napisano całą masę artykułów. Dlatego też poniżej postaram się przedstawić kilka mniej znanych, skupiając się szczególnie na tych, które są istotne z punktu widzenia JS, przez wzgląd na możliwości jakie daje oraz brakujących konstrukcji dostępnych w innych językach, których tutaj brakuje &ndash; w gruncie rzeczy czym są wzorce projektowe, jeżeli nie powszechnymi sposobami na obejście braków odpowiednich konstruktów w danym języku programowania?</p>

<h2>Funkcje natychmiastowe</h2>

<p>Mechanizm funkcji natychmiastowych (<strong>immediate functions</strong>) jest jedną z podstawowych sztuczek językowych wykorzystywanych w Javascriptcie. Ponieważ wiedza ta stanowi fundament innych wzorców, przedstawię go poniżej.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">immediateValue</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>  <span class="c1">// wykonujemy jakąś operację i zwracamy wartosć</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
</span><span class='line'>  <span class="p">})();</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// określamy zewnętrzne obiekty, które wywołujemy wewnątrz funkcji</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">module</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nb">window</span><span class="p">,</span> <span class="nb">document</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">// wykonujemy jakąś operację</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">module</span><span class="p">;</span>
</span><span class='line'><span class="p">})(</span><span class="nb">window</span><span class="p">,</span> <span class="nb">document</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Jak widzimy całość polega na jednoczesnym zdefiniowaniu funkcji i jej wykonaniu. Jakie są zalety tego podejścia?:</p>

<ul>
<li>Możemy w ten sposób budować moduły &ndash; ponieważ zawartość funkcji powoduje stworzenie nowego zakresu (scope &ndash; chociaż z tym ze względów wydajnościowych nie należy przeginać), wszystkie zmienne lokalne użyte w funkcji-module nie są widoczne spoza niej, dopóki programista jawnie nie określi inaczej.</li>
<li>Przekazując parametry do takiej funkcji możemy jawnie określić zależności pomiędzy operacjami/obiektami używanymi wewnątrz funkcji ze światem zewnętrznym.</li>
</ul>


<h2>Modularyzacja</h2>

<p>Jest to dość często poruszany problem (sam nieraz o nim wspominałem), ponieważ JS jako tako sam nie umożliwia definiowania pakietów ani przestrzeni nazw. Stąd też pierwszym zaprezentowanym przeze mnie wzorcem będzie <strong>namespace</strong>. Ponieważ przykładowy kod umieściłem i opisałem w jednym z poprzednich <a href="http://horusiath.blogspot.com/2012/09/javascript-porady-i-uwagi.html">postów</a>, gwoli przypomnienia umieszczę tutaj przykładowy kod takiego rozwiązania.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nb">window</span><span class="p">.</span><span class="nx">namespace</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">parent</span> <span class="o">=</span> <span class="nx">root</span> <span class="o">||</span> <span class="nb">window</span><span class="p">;</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">modules</span> <span class="o">=</span> <span class="nx">path</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="kd">var</span> <span class="nx">module</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span><span class='line'>      <span class="nx">parent</span><span class="p">[</span><span class="nx">module</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">parent</span><span class="p">[</span><span class="nx">module</span><span class="p">]</span> <span class="o">||</span> <span class="p">{});</span>
</span><span class='line'>      <span class="nx">parent</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">[</span><span class="nx">module</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">parent</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Cache&#8217;owanie funkcji</h2>

<p>Ze względu na silniki starszych przeglądarek i chęć ograniczenia skomplikowanych operacji wiele bibliotek oferuje mniej lub bardziej wyrafinowane mechanizmy służące cache&#8217;owaniu danych. Javascript przychodzi tutaj z pomocą, pozwalając na zastosowanie tej techniki niemal dla dowolnej funkcji. Mowa tutaj o wzorcu <strong>memoization</strong>. Wykorzystuje on dwa podstawowe fakty dotyczące tego języka:</p>

<ol>
<li>Każda funkcja jest jednocześnie pełnoprawnym obiektem.</li>
<li>Każdy obiekt może pełnić funkcje słownika &ndash; a co za tym idzie można wykorzystać go do dynamicznego przydzielania nowych właściwości i hashy.</li>
</ol>


<p>Poniższy kod przedstawia najprostszą implementację tego zachowania:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">memoizedFunction</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>  <span class="c1">// parametr {value} stanowi jednocześnie klucz w naszym cache&#39;u</span>
</span><span class='line'>  <span class="kd">function</span> <span class="nx">fn</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
</span><span class='line'>      <span class="c1">// sprawdzmy, czy parametr został wcześniej zapamiętany</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="nx">fn</span><span class="p">.</span><span class="nx">_cache</span><span class="p">[</span><span class="nx">value</span><span class="p">]){</span>
</span><span class='line'>          <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">_cache</span><span class="p">[</span><span class="nx">value</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>          <span class="c1">// zapamiętywanie wywołania funkcji</span>
</span><span class='line'>          <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">doSomething</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
</span><span class='line'>          <span class="nx">fn</span><span class="p">.</span><span class="nx">_cache</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
</span><span class='line'>          <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">fn</span><span class="p">.</span><span class="nx">_cache</span> <span class="o">=</span> <span class="p">{};</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">fn</span><span class="p">;</span>
</span><span class='line'><span class="p">})();</span>
</span></code></pre></td></tr></table></div></figure>


<p>Należy zwrócić uwagę na fakt, że parametr przekazywany do funkcji w tej implementacji stanowi jednocześnie wartość cache&#8217;owanego klucza, a sam wzorzec musi implementować funkcje deteministyczne (tzn. takie które dla tego samego parametru wejściowego zwracają zawsze tą samą wartość/wykonują tę samą operacje). Stąd też dobrze, jeżeli maksymalna możliwa liczba przekazywanych parametrów jest znana &ndash; w sytuacjach skrajnych mogłoby dojść do tego, że cache zacząłby zajmować ogromną ilość pamięci. W takim wypadku trzeba dodatkowo zaimplementować dodatkowo mechanizm odśmiecania lub okresowego czyszczenia cache&#8217;u.</p>

<p>Prawidłowe działanie funkcji w dużej mierze zależy od typu przekazywanego parametru &ndash; ze względu na to, że Javascript bywa dość nieprzewidywalny, najlepiej jest trzymać się typów prostych: String, Number, Boolean. W praktyce jednak wszystko to jednak zależy od twojej znajomości tricków i pułapek tego języka.</p>

<p>Gdzie przydaje się powyższy wzorzec? Kilka przykładów:</p>

<ul>
<li>W wywołaniach do serwera np. jeżeli dla podanego adresu URL zwracana wartość jest stała, możemy użyć go w postaci klucza i zapamiętać zwracaną wartość. W ten sposób zmniejszymy czas i ilość requestów na serwer potrzebnych do skończenia danej operacji.</li>
<li>Inne funkcje o stałych kluczach, ale jednocześnie wykonujące złożone obliczenia np. w mechanizmach bindowania danych do modelu DOM przeglądarki.</li>
</ul>


<h2>Dependency Injection</h2>

<p>Pojęcie to jest ostatnio dość często używane, również ze względu na rosnącą popularność frameworków MVC. W Javascriptcie zostało ono użyte po raz pierwszy w dużej skali wraz z nadejściem <a href="http://angularjs.org/">AngularJS</a>. Jednakże, jeżeli chcielibyśmy, możemy zaimplementować kontener <strong>Inversion of Control</strong> dla własnych potrzeb.</p>

<p>W pierwszej kolejności zdefiniujmy kontener IoC.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// kontener IoC</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">DependencyResolver</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
</span><span class='line'>  <span class="c1">// regex użyty do wyciągania nazw zależności z konstruktora</span>
</span><span class='line'>  <span class="nx">ARG_REGEX</span> <span class="o">=</span> <span class="sr">/^function\s*[^\(]*\(\s*([^\)]*)\)/m</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">dependencies</span> <span class="o">=</span> <span class="p">{};</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">// funkcja rejestrująca typ w kontenerze</span>
</span><span class='line'>  <span class="k">this</span><span class="p">.</span><span class="nx">register</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">type</span><span class="p">){</span>
</span><span class='line'>      <span class="nx">dependencies</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">type</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">// zwraca instancję obiektu identyfikowanego po podanym kluczu </span>
</span><span class='line'>  <span class="k">this</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">){</span> <span class="p">...</span> <span class="p">};</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">// rozwiązujemy podane zależności podane w postaci listy kluczy</span>
</span><span class='line'>  <span class="c1">// dla dependency resolvera do postaci tablicy gotowych obiektów</span>
</span><span class='line'>  <span class="kd">function</span> <span class="nx">resolveDependencies</span><span class="p">(</span><span class="nx">args</span><span class="p">){</span> <span class="p">...</span> <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>&ldquo;Klasa&rdquo; ta udostępnia dwie metody:</p>

<ul>
<li><code>register(key, type)</code> &ndash; rejestruje podaną wartość/funkcję konstruktora pod podanym kluczem.</li>
<li><code>resolve(key)</code> &ndash; tworzy typ zgodnie z zarejestrowaną wcześniej nazwą.</li>
</ul>


<p>Niestety javascript nie przechowuje informacji na temat typów parametrów pobieranych przez funkcję. Stąd też twórcy AngularJS postanowili zbudować następującą konwencję &ndash; w momencie, gdy przy próbie utworzenia obiektu pojawiaja się problem z określeniem typu argumentów przekazywanych do konstruktora, przyjmuje się, że nazwy parametrów są kluczami dla wartosci zarejestrowanych w kontenerze IoC. Jak to wygląda w praktyce? Ilustruje to następujący kod:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// budujemy kontener</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">resolver</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DependencyResolver</span><span class="p">();</span>
</span><span class='line'><span class="nx">resolver</span><span class="p">.</span><span class="nx">register</span><span class="p">(</span><span class="s1">&#39;valueA&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// rejestrujemy 1 dla klucza &#39;valueA&#39;</span>
</span><span class='line'><span class="nx">resolver</span><span class="p">.</span><span class="nx">register</span><span class="p">(</span><span class="s1">&#39;valueB&#39;</span><span class="p">,</span> <span class="nx">MyClass1</span><span class="p">);</span> <span class="c1">// rejestrujemy &quot;klasę&quot; dla klucza &#39;valueB&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// tworzymy nową &quot;klasę&quot; i rejestrujemy ją jako &#39;valueC&#39;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">MyClass2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">valueA</span><span class="p">,</span> <span class="nx">valueB</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// kontener wygeneruje opowiednie wartosci sugerując się nazwami parametrów</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">resolver</span><span class="p">.</span><span class="nx">register</span><span class="p">(</span><span class="s1">&#39;valueC&#39;</span><span class="p">,</span> <span class="nx">MyClass2</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// tworzymy obiekt</span>
</span><span class='line'><span class="nx">resolver</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;valueC&#39;</span><span class="p">);</span> <span class="c1">// profit ;)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ciało metody resolve przedstawia się w takim wypadku następująco:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">this</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">){</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">type</span> <span class="o">=</span> <span class="nx">dependencies</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">// jeżeli zarejestrowany typ jest funkcją/konstruktorem</span>
</span><span class='line'>  <span class="c1">// musimy rozwiązać listę parametrów podanych do dokonstruktora</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">type</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">){</span>
</span><span class='line'>      
</span><span class='line'>      <span class="c1">// wyciągamy listę wartości przyjmowanych przez konstruktor</span>
</span><span class='line'>      <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">ARG_REGEX</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">type</span><span class="p">.</span><span class="nx">toString</span><span class="p">())[</span><span class="mi">1</span><span class="p">].</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">);</span>
</span><span class='line'>      <span class="c1">// zamieniamy je na właściwe obiekty</span>
</span><span class='line'>      <span class="kd">var</span> <span class="nx">resolvedArgs</span> <span class="o">=</span> <span class="nx">resolveDependencies</span><span class="p">(</span><span class="nx">args</span><span class="p">);</span>
</span><span class='line'>      
</span><span class='line'>      <span class="c1">// tworzymy nową instancję danego typu</span>
</span><span class='line'>      <span class="kd">var</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">type</span><span class="p">();</span>
</span><span class='line'>      <span class="nx">type</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">instance</span><span class="p">,</span> <span class="nx">resolvedArgs</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">instance</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// jeżeli typ jest typem prostym wystarczy go zwrócić</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">type</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Natomiast brakujące ciało metody resolveDependencies:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">resolveDependencies</span><span class="p">(</span><span class="nx">args</span><span class="p">){</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">resolvedArgs</span> <span class="o">=</span> <span class="p">[];</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
</span><span class='line'>      <span class="kd">var</span> <span class="nx">dependency</span> <span class="o">=</span> <span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">trim</span><span class="p">();</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="nx">dependency</span> <span class="o">!==</span> <span class="s1">&#39;&#39;</span><span class="p">){</span>
</span><span class='line'>          <span class="kd">var</span> <span class="nx">resolved</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="nx">dependency</span><span class="p">);</span>
</span><span class='line'>          <span class="nx">resolvedArgs</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">resolved</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">resolvedArgs</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Oczywiście powyższy kod nie określa kwestii czasu życia obiektu, którą kontenery IoC przeważnie rozwiązują. Jednakże jaki problem tkwi w powyższym rozwiązaniu? Otóż w momencie minimalizacji danego skryptu cała nasza wiedza o nazewnictwie parametrów funkcji znika (zostają one zastąpione krótkimi &ndash; z reguły jednoliterowymi aliasami). Niestety ale nie da się tego rozwiązać w elegancki sposób. W przypadku AngularJS zdefiniowana została specjalna właściwość $inject, którą dodajemy własnoręcznie do danej klasy, a która definiuje tablicę kluczy-parametrów, dzięki którym możliwe jest rozwiązanie zależności przez kontener. W takim wypadku w powyższej implementacji wystarczy dodać drobne usprawnienie:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">this</span><span class="p">.</span><span class="nx">resolve</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">){</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">type</span><span class="p">.</span><span class="nx">$inject</span> <span class="o">||</span> <span class="nx">ARG_REGEX</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">type</span><span class="p">.</span><span class="nx">toString</span><span class="p">())[</span><span class="mi">1</span><span class="p">].</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>, natomiast, w samej zdefiniowanej klasie:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">MyClass</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">valueA</span><span class="p">,</span> <span class="nx">valueB</span><span class="p">){</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'><span class="nx">MyClass</span><span class="p">.</span><span class="nx">$inject</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;valueA&#39;</span><span class="p">,</span> <span class="s1">&#39;valueB&#39;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>Dlaczego ten mechanizm się przydaje? Odpowiedź jest dokładnie taka sama jak w przypadku DI po stronie serwera: modularyzacja projektu, spójny sposób i kontrola nad konstrukcją obiektów. Całość jest wprost nieoceniona, kiedy po stronie klienta wykonywany jest bardziej zaawansowany wycinek logiki. A do tego te wsparcie dla testów jednostkowych.</p>

<p>P.S.: Jestem zdania, że w każdym projekcie z większą ilością Javascriptu testy jednostkowe są nieocenione. Po pierwsze w tym języku wyjątkowo łatwo o błędy i niezdarny kod, a TDD oraz BDD rozwiązują oba te problemy. Po drugie jesteśmy po stronie klienta. Chcesz sprawdzić czy logika do kontrolek User Interface i wyświetlanie strony działa prawidłowo? Gratulacje &ndash; jesteś po właściwej stronie kabla.</p>

<h2>Dziedziczenie</h2>

<p>Pomimo, że Javascript jest językiem obiektowym, nie definiuje jednak mechanizmu dziedziczenia w sposób znany nam z innych języków. Na szczęście jego możliwości pozwalają nam na wykonanie takiego mechanizmu w postaci wzorca <strong>extend</strong> (<em>powered by CoffeScript ;)</em> ).</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">extend</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">childPrototype</span><span class="p">,</span> <span class="nx">superPrototype</span><span class="p">){</span>
</span><span class='line'>  <span class="c1">// dziedziczenie składowych</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">property</span> <span class="k">in</span> <span class="nx">superPrototype</span><span class="p">){</span>
</span><span class='line'>      <span class="c1">// iterujemy po wszystkich składowych rodzica</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="nx">superPrototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">property</span><span class="p">)){</span>
</span><span class='line'>          <span class="nx">childPrototype</span><span class="p">[</span><span class="nx">property</span><span class="p">]</span> <span class="o">=</span> <span class="nx">superPrototype</span><span class="p">[</span><span class="nx">property</span><span class="p">]</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">// dziedziczenie konstruktora</span>
</span><span class='line'>  <span class="kd">function</span> <span class="nx">ctor</span><span class="p">(){</span>
</span><span class='line'>      <span class="k">this</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">=</span> <span class="nx">childPrototype</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="nx">ctor</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">superPrototype</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">childPrototype</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ctor</span><span class="p">();</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">// definiujemy dostęp do &quot;klasy bazowej&quot;</span>
</span><span class='line'>  <span class="nx">childPrototype</span><span class="p">.</span><span class="nx">__super__</span> <span class="o">=</span> <span class="nx">superPrototype</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">childPrototype</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Niestety, jeżeli chcemy mieć dostęp do &ldquo;wirtualizacji&rdquo; metod w klasach pochodnych, musimy to wykonywać w dość krzywy sposób. Przykład poniżej.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// klasa bazowa</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">Parent</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>  <span class="kd">function</span> <span class="nx">Parent</span><span class="p">(</span><span class="nx">firstName</span><span class="p">){</span>
</span><span class='line'>      <span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">=</span> <span class="nx">firstName</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// definiujemy &quot;wirtualną&quot; metodę</span>
</span><span class='line'>  <span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">show</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>      <span class="k">return</span> <span class="s2">&quot;Base: &quot;</span><span class="o">+</span><span class="k">this</span><span class="p">.</span><span class="nx">firstName</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">Parent</span><span class="p">;</span>
</span><span class='line'><span class="p">})();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// klasa pochodna</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">Child</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">BaseType</span><span class="p">){</span>
</span><span class='line'>  <span class="nx">extend</span><span class="p">(</span><span class="nx">Child</span><span class="p">,</span> <span class="nx">BaseType</span><span class="p">);</span> <span class="c1">// określamy warunki dziedziczenia</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">function</span> <span class="nx">Child</span><span class="p">(</span><span class="nx">firstName</span><span class="p">,</span> <span class="nx">lastName</span><span class="p">){</span>
</span><span class='line'>      <span class="c1">// wywołujemy konstruktor z klasy bazowej</span>
</span><span class='line'>      <span class="nx">Child</span><span class="p">.</span><span class="nx">__super__</span><span class="p">.</span><span class="nx">constructor</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">firstName</span><span class="p">);</span>
</span><span class='line'>      <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span> <span class="o">=</span> <span class="nx">lastName</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// &quot;nadpisujemy&quot; metodę z klasy bazowej</span>
</span><span class='line'>  <span class="nx">Child</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">show</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>      <span class="c1">// wewnątrz nadpisanej metody wywołujemy jej bazową postać</span>
</span><span class='line'>      <span class="kd">var</span> <span class="nx">baseMessage</span> <span class="o">=</span> <span class="nx">Child</span><span class="p">.</span><span class="nx">__super__</span><span class="p">.</span><span class="nx">show</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="s2">&quot;Inherited: &quot;</span><span class="o">+</span><span class="k">this</span><span class="p">.</span><span class="nx">lastName</span> <span class="o">+</span> <span class="s2">&quot; with &quot;</span> <span class="o">+</span> <span class="nx">baseMessage</span><span class="p">;</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">Child</span><span class="p">;</span>
</span><span class='line'><span class="p">})(</span><span class="nx">Parent</span><span class="p">);</span> <span class="c1">// przekazujemy klasę bazową mechanizmem funkcji natychmiastowej</span>
</span></code></pre></td></tr></table></div></figure>


<p>Jak widać, nie jest to technika przejrzysta, głównie ze względu na obejścia, jakie trzeba wykonać, aby uzyskać dostęp do wywołań metod nadpisywanych z klas bazowych.</p>

<p>Kiedy jest to przydatne? Szczerze umieściłem to jako ciekawostkę, ponieważ o ile o korzyściach dziedziczenia i wirtualizacji wie chyba każdy, kto miał do czynienia z programowaniem obiektowym, to forma, w jakiej jest to podane w Javascriptcie może okazać się ciężka do przełknięcia. Z tego powodu polecam tutaj języki kompilowane do Javascriptu np. CoffeeScript lub TypeScript, które rozwiązują ten problem za nas.</p>
</div>

</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	<a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
	
	
	<a class="addthis_button_tweet"></a>
	
	
	<a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>


</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Bartosz Sypytkowski


Design based on: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
</body>
</html>
