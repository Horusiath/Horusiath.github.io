
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>Simple Virtual Machine - Simple Solutions</title>
	<meta name="author" content="Bartosz Sypytkowski">

	
	<meta name="description" content="Simple Virtual Machine In this post I want to present, how to create a simple virtual machine with it&rsquo;s own bytecode interpreter. While it& &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Simple Solutions" type="application/atom+xml">
	
	<link rel="canonical" href="http://bartoszsypytkowski.com/blog/2014/08/02/simple-vm/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	

<script type="text/javascript">
      var disqus_shortname = 'bartoszsypytkowski';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://bartoszsypytkowski.com/blog/2014/08/02/simple-vm/';
        var disqus_url = 'http://bartoszsypytkowski.com/blog/2014/08/02/simple-vm/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


  
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-47294845-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><h1 id="profile-name"><a href="/">Bartosz Sypytkowski</a></h1>
<div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("b.sypytkowski@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:b.sypytkowski@gmail.com" title="Email">Email</a>
		
		
		
			<a class="google" href="https://plus.google.com/b.sypytkowski@gmail.com" rel="author" title="Google+">Google+</a>
		
		
			<a class="twitter" href="http://twitter.com/horusiath" title="Twitter">Twitter</a>
		
		
			<a class="github" href="https://github.com/horusiath" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		
		
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">Simple Virtual Machine</h1>
	<div class="entry-content" itemprop="articleBody"><p>In this post I want to present, how to create a simple virtual machine with it&rsquo;s own bytecode interpreter. While it&rsquo;s created using C language, it doesn&rsquo;t use any complex constructs and could be possibly implemented the same with any imperative language.</p>

<p>NOTE: while in this example bytecode instruction set is limited to the simple integer operations, real life virtual machines usually have a lot more complex operands (eg. object creation instruction in VMs with managed memory or dynamic method invocations). Have in mind that even if your Intermediate Representation may look like some BASIC/ASM language, it really could abstract much higher level functionalities.</p>

<h3>Virtual Machine</h3>

<p>Lets start with precising, what our virtual machine should consist of. In this example, we&rsquo;ll create a stack-based virtual machine. What does it mean? There is no notion of registers and all operation are performed through virtual stack. This results in simpler (since our instruction set doesn&rsquo;t have to include virtual registers operations), but also longer bytecode &ndash; because of more operations have to be executed than in alternative option, which may support a virtual register calls.</p>

<p>In this example, our virtual machine will consist of:</p>

<ul>
<li><strong>Executable code pointer</strong> &ndash; in order to execute the program, a VM has to now what program it is ;) Our bytecode contains opcodes (which are integers used to define instructions to be executed by an interpreter) and numbers used for things such as constant values, memory addresses or stack offsets.</li>
<li><strong>Stack</strong> &ndash; virtual stack will work as fragment of memory used for storing intermediate results and additional data of each instruction. When a procedure call will be invoked, it will also save a state of the program at moment, when procedure has been called, to retrieve it back after program will return from that call.</li>
<li><strong>Heap</strong> &ndash; unlike the stack, which uses LIFO (Last-In First-Out) operations, heap may be used as random access memory. It also may change it&rsquo;s size according to program needs. In this example we may use it to store both global and local variables.</li>
<li><strong>Program counter</strong> &ndash; it contains an address of currently executed instruction. Program will be executed by moving PC through instruction set, reading opcodes and executing them.</li>
<li><strong>Stack pointer</strong> &ndash; it contains information about number of elements stored on the stack. It always points on the top of it.</li>
<li><strong>Frame pointer</strong> &ndash; since we need to differentiate a locally and globally scoped values (this includes function arguments), we need to know where our scope is located on the stack. All local variables are assigned relatively to FP position.</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// stack will have fixed size</span>
</span><span class='line'><span class="cp">#define STACK_SIZE 100</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span><span class="o">*</span> <span class="n">heap</span><span class="p">;</span>      <span class="c1">// heap</span>
</span><span class='line'>    <span class="kt">int</span><span class="o">*</span> <span class="n">code</span><span class="p">;</span>      <span class="c1">// array od byte codes to be executed</span>
</span><span class='line'>    <span class="kt">int</span><span class="o">*</span> <span class="n">stack</span><span class="p">;</span>     <span class="c1">// virtual stack</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">pc</span><span class="p">;</span>         <span class="c1">// program counter (aka. IP - instruction pointer)</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">sp</span><span class="p">;</span>         <span class="c1">// stack pointer</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">fp</span><span class="p">;</span>         <span class="c1">// frame pointer (for local scope)</span>
</span><span class='line'><span class="p">}</span> <span class="n">VM</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">VM</span><span class="o">*</span> <span class="nf">newVM</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">code</span><span class="p">,</span>    <span class="c1">// pointer to table containing a bytecode to be executed</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">pc</span><span class="p">,</span>             <span class="c1">// address of instruction to be invoked as first one - entrypoint/main func</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">datasize</span><span class="p">){</span>      <span class="c1">// total heap size required to perform a program operations</span>
</span><span class='line'>    <span class="n">VM</span><span class="o">*</span> <span class="n">vm</span> <span class="o">=</span> <span class="p">(</span><span class="n">VM</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">VM</span><span class="p">));</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">code</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="n">pc</span><span class="p">;</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">heap</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">datasize</span><span class="p">);</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">stack</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">STACK_SIZE</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">vm</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">delVM</span><span class="p">(</span><span class="n">VM</span><span class="o">*</span> <span class="n">vm</span><span class="p">){</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">vm</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">);</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">vm</span><span class="o">-&gt;</span><span class="n">stack</span><span class="p">);</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Bytecode instruction set</h3>

<p>At the begginig we&rsquo;ll start from defining a set of instructions to be handled by our language. For sake of simplicity we&rsquo;ll focus on basic integer operations, printing their result, variable creation and procedure-oriented calls.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">enum</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ADD_I32</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>    <span class="c1">// int add</span>
</span><span class='line'>    <span class="n">SUB_I32</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>    <span class="c1">// int sub</span>
</span><span class='line'>    <span class="n">MUL_I32</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>    <span class="c1">// int mul</span>
</span><span class='line'>    <span class="n">LT_I32</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>     <span class="c1">// int less than</span>
</span><span class='line'>    <span class="n">EQ_I32</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>     <span class="c1">// int equal</span>
</span><span class='line'>    <span class="n">JMP</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>        <span class="c1">// branch</span>
</span><span class='line'>    <span class="n">JMPT</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>       <span class="c1">// branch if true</span>
</span><span class='line'>    <span class="n">JMPF</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>       <span class="c1">// branch if false</span>
</span><span class='line'>    <span class="n">CONST_I32</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>  <span class="c1">// push constant integer</span>
</span><span class='line'>    <span class="n">LOAD</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>      <span class="c1">// load from local</span>
</span><span class='line'>    <span class="n">GLOAD</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>     <span class="c1">// load from global</span>
</span><span class='line'>    <span class="n">STORE</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span>     <span class="c1">// store in local</span>
</span><span class='line'>    <span class="n">GSTORE</span> <span class="o">=</span> <span class="mi">13</span><span class="p">,</span>    <span class="c1">// store in global memory</span>
</span><span class='line'>    <span class="n">PRINT</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span>     <span class="c1">// print value on top of the stack</span>
</span><span class='line'>    <span class="n">POP</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>       <span class="c1">// throw away top of the stack</span>
</span><span class='line'>    <span class="n">HALT</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>      <span class="c1">// stop program</span>
</span><span class='line'>    <span class="n">CALL</span> <span class="o">=</span> <span class="mi">17</span><span class="p">,</span>      <span class="c1">// call procedure</span>
</span><span class='line'>    <span class="n">RET</span> <span class="o">=</span> <span class="mi">18</span>        <span class="c1">// return from procedure</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Just like in standard assembly code, each instruction is represented by specific byte number. In more realistic virtual machine those numbers may have specific values (for example to perform bitwise masking).</p>

<h3>Main interpreter loop</h3>

<p>It&rsquo;s time to create our code execution loop. How does it work? It&rsquo;s a simple loop with switch statement used to interpret particular operation codes found in our program. While this is not the fastest solution, it gives us a simple understanding of how fetch/decode/execute cycle works.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define PUSH(vm, v) vm-&gt;stack[++vm-&gt;sp] = v </span><span class="c1">// push value on top of the stack</span>
</span><span class='line'><span class="cp">#define POP(vm)     vm-&gt;stack[vm-&gt;sp--]     </span><span class="c1">// pop value from top of the stack</span>
</span><span class='line'><span class="cp">#define NCODE(vm)   vm-&gt;code[vm-&gt;pc++]      </span><span class="c1">// get next bytecode</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">run</span><span class="p">(</span><span class="n">VM</span><span class="o">*</span> <span class="n">vm</span><span class="p">){</span>
</span><span class='line'>    <span class="k">do</span><span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">opcode</span> <span class="o">=</span> <span class="n">NCODE</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>        <span class="c1">// fetch</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">rval</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// decode</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">HALT</span>: <span class="k">return</span><span class="p">;</span>  <span class="c1">// stop the program</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">CONST_I32</span>: <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">ADD_I32</span>: <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">SUB_I32</span>: <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">MUL_I32</span>: <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">LT_I32</span>: <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">EQ_I32</span>: <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">JMP</span>: <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">JMPT</span>: <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">JMPF</span>: <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">LOAD</span>:  <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">GLOAD</span>: <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">GSTORE</span>: <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">CALL</span>: <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">RET</span>: <span class="p">...</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">POP</span>:
</span><span class='line'>            <span class="o">--</span><span class="n">vm</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">;</span>      <span class="c1">// throw away value at top of the stack</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">PRINT</span>:
</span><span class='line'>            <span class="n">v</span> <span class="o">=</span> <span class="n">POP</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>        <span class="c1">// pop value from top of the stack ...</span>
</span><span class='line'>            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>  <span class="c1">// ... and print it</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="nl">default:</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here we&rsquo;ve already defined <code>HALT</code>, <code>POP</code> and <code>PRINT</code> opcodes. In more realistic example, you probably don&rsquo;t want to define value display in form of dedicated instruction, but this will allow us to simply see result of our operations.</p>

<h3>Integer operators</h3>

<p>Now we can define some integer operations. While we&rsquo;re defined a plenty of them, here I&rsquo;ll show only one example for each group: constant initialization, arithmetic and logic operations.</p>

<p>What is worth emphasizing, is that all value swaps are performed through stack (there are no registers), so each instruction takes it&rsquo;s operands from top of the stack and also puts a computed result on top of it. Also, since stacks are LIFO-type collections, all values taken from the stack are in reversed order &ndash; for example look at <code>ADD_I32</code> instruction below.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">case</span> <span class="n">CONST_I32</span>:
</span><span class='line'>    <span class="n">v</span> <span class="o">=</span> <span class="n">NCODE</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>   <span class="c1">// get next value from code ...</span>
</span><span class='line'>    <span class="n">PUSH</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>     <span class="c1">// ... and move it on top of the stack</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="k">case</span> <span class="n">ADD_I32</span>:
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">POP</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>        <span class="c1">// get second value from top of the stack ...</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">POP</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>        <span class="c1">// ... then get first value from top of the stack ...</span>
</span><span class='line'>    <span class="n">PUSH</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>    <span class="c1">// ... add those two values and put result on top of the stack</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="k">case</span> <span class="n">LT_I32</span>:
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">POP</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>        <span class="c1">// get second value from top of the stack ...</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">POP</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>        <span class="c1">// ... then get first value from top of the stack ...</span>
</span><span class='line'>    <span class="n">PUSH</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="o">&lt;</span><span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// ... compare those two values, and put result on top of the stack</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Instructions such as <code>SUB_I32</code>, <code>MUL_I32</code> and <code>EQ_I32</code> won&rsquo;t be defined in scope of this post, but I think when you&rsquo;ll understand example above, they should be easy to implement.</p>

<h3>Jump instructions</h3>

<p>Next, we have to define jump instructions in our code. They are basically equivalent of <code>goto</code> keyword and may be used to implement statements such as loops and if/else conditions.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">case</span> <span class="n">JMP</span>:
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="n">NCODE</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>  <span class="c1">// unconditionaly jump with program counter to provided address</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="k">case</span> <span class="n">JMPT</span>:
</span><span class='line'>    <span class="n">addr</span> <span class="o">=</span> <span class="n">NCODE</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>  <span class="c1">// get address pointer from code ...</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">POP</span><span class="p">(</span><span class="n">vm</span><span class="p">))</span> <span class="p">{</span>      <span class="c1">// ... pop value from top of the stack, and if it&#39;s true ...</span>
</span><span class='line'>        <span class="n">vm</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span> <span class="c1">// ... jump with program counter to provided address</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Again, <code>JUMPF</code> (conditional jump if false) implementation should be analogous to <code>JMPT</code>.</p>

<h3>Move memory on the heap globally</h3>

<p>Now, when all basic constructs are defined, we shall provide a way to define a variables in our program. This paragraph will cover problem of globally-scoped ones, while the next one will show how to implement locally-scoped variables.</p>

<p>Unlike stack, a heap is a random access memory of elastic size, so all in/out operations performed on it using memory addresses (aka. pointers). Therefore in our example all load/store opcodes should be followed by number being an address pointer to the heap.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">case</span> <span class="n">GLOAD</span>:
</span><span class='line'>    <span class="n">addr</span> <span class="o">=</span> <span class="n">POP</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>             <span class="c1">// get pointer address from code ...</span>
</span><span class='line'>    <span class="n">v</span> <span class="o">=</span> <span class="n">vm</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">addr</span><span class="p">];</span>         <span class="c1">// ... load value from memory of the provided addres ...</span>
</span><span class='line'>    <span class="n">PUSH</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>                <span class="c1">// ... and put that value on top of the stack</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="k">case</span> <span class="n">GSTORE</span>:
</span><span class='line'>    <span class="n">v</span> <span class="o">=</span> <span class="n">POP</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>                <span class="c1">// get value from top of the stack ...</span>
</span><span class='line'>    <span class="n">addr</span> <span class="o">=</span> <span class="n">NCODE</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>           <span class="c1">// ... get pointer address from code ...</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>         <span class="c1">// ... and store value at address received</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Manipulate local scope memory</h3>

<p>This is similar to previously defined <code>GLOAD</code> and <code>GSTORE</code> instruction. However there is a one significant difference &ndash; instead of taking an heap address directly from provided value, we compute it relatively to current frame pointer.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">case</span> <span class="n">LOAD</span>:                  <span class="c1">// load local value or function arg</span>
</span><span class='line'>    <span class="n">offset</span> <span class="o">=</span> <span class="n">NCODE</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>     <span class="c1">// get next value from code to identify local variables offset start on the stack</span>
</span><span class='line'>    <span class="n">PUSH</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">vm</span><span class="o">-&gt;</span><span class="n">stack</span><span class="p">[</span><span class="n">vm</span><span class="o">-&gt;</span><span class="n">fp</span><span class="o">+</span><span class="n">offset</span><span class="p">]);</span> <span class="c1">// ... put on the top of the stack variable stored relatively to frame pointer</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="k">case</span> <span class="n">STORE</span>:                 <span class="c1">// store local value or function arg</span>
</span><span class='line'>    <span class="n">v</span> <span class="o">=</span> <span class="n">POP</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>            <span class="c1">// get value from top of the stack ...</span>
</span><span class='line'>    <span class="n">offset</span> <span class="o">=</span> <span class="n">NCODE</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>     <span class="c1">// ... get the relative pointer address from code ...</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">[</span><span class="n">vm</span><span class="o">-&gt;</span><span class="n">fp</span><span class="o">+</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>  <span class="c1">// ... and store value at address received relatively to frame pointer</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Procedure calls</h3>

<p>All of previous instructions were fairly simple to execute. Now it&rsquo;s time to do something slightly more complex &ndash; function/procedure calls. Before we begin, lets describe how they works. To perform the call, we have to first save the current state of the program at the moment before the call will be performed &ndash; it will let us freely alter program state in scope of the function. To do so, we have to save three values:</p>

<ul>
<li>Address of the caller instruction &ndash; this is a current value of program counter and it&rsquo;s need to be stored, so that VM will know, where program should return from finished procedure call.</li>
<li>Frame pointer &ndash; this is necessary, since we want to be able to use locally scoped variables when we enter into new procedure (<strong>tl;dr</strong> &ndash; it gives us a function scope feature).</li>
<li>Number of function/procedure arguments &ndash; before call will be performed, all necessary arguments will be put on top of the stack. However returning from function should dispose all of the provided arguments, so that we could retrieve back state of the stack from before the function call. If we want to know how many arguments from the stack should be thrown away, firstly we have to store that count &ndash; it will be also put on top of the stack.</li>
</ul>


<p><code>RET</code> instruction works in reverse order &ndash; it takes value from top of the stack as function return value, rollbacks frame pointers, moves program counter to the caller instruction, disposes all of function call arguments from the stack and replaces all of these with return value.</p>

<p>Because we&rsquo;ve stored all of those values on top of the stack, we&rsquo;re able to store next consecutive calls in the same manner. It means that, we&rsquo;re able to nest our procedure calls. However, since each call stores some portion of data on the stack, at some point we may run out of memory, which cause stack overflow error.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">case</span> <span class="n">CALL</span>:
</span><span class='line'>    <span class="c1">// we expect all args to be on the stack</span>
</span><span class='line'>    <span class="n">addr</span> <span class="o">=</span> <span class="n">NCODE</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span> <span class="c1">// get next instruction as an address of procedure jump ...</span>
</span><span class='line'>    <span class="n">argc</span> <span class="o">=</span> <span class="n">NCODE</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span> <span class="c1">// ... and next one as number of arguments to load ...</span>
</span><span class='line'>    <span class="n">PUSH</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">argc</span><span class="p">);</span>   <span class="c1">// ... save num args ...</span>
</span><span class='line'>    <span class="n">PUSH</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">vm</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">);</span> <span class="c1">// ... save function pointer ...</span>
</span><span class='line'>    <span class="n">PUSH</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">vm</span><span class="o">-&gt;</span><span class="n">pc</span><span class="p">);</span> <span class="c1">// ... save instruction pointer ...</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">=</span> <span class="n">vm</span><span class="o">-&gt;</span><span class="n">sp</span><span class="p">;</span>  <span class="c1">// ... set new frame pointer ...</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>    <span class="c1">// ... move instruction pointer to target procedure address</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="k">case</span> <span class="n">RET</span>:
</span><span class='line'>    <span class="n">rval</span> <span class="o">=</span> <span class="n">POP</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>     <span class="c1">// pop return value from top of the stack</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">=</span> <span class="n">vm</span><span class="o">-&gt;</span><span class="n">fp</span><span class="p">;</span>    <span class="c1">// ... return from procedure address ...</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">pc</span> <span class="o">=</span> <span class="n">POP</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>   <span class="c1">// ... restore instruction pointer ...</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">fp</span> <span class="o">=</span> <span class="n">POP</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>   <span class="c1">// ... restore framepointer ...</span>
</span><span class='line'>    <span class="n">argc</span> <span class="o">=</span> <span class="n">POP</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>     <span class="c1">// ... hom many args procedure has ...</span>
</span><span class='line'>    <span class="n">vm</span><span class="o">-&gt;</span><span class="n">sp</span> <span class="o">-=</span> <span class="n">argc</span><span class="p">;</span>     <span class="c1">// ... discard all of the args left ...</span>
</span><span class='line'>    <span class="n">PUSH</span><span class="p">(</span><span class="n">vm</span><span class="p">,</span> <span class="n">rval</span><span class="p">);</span>     <span class="c1">// ... leave return value on top of the stack</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Example code</h3>

<p>Now, when our bytecode interpreter is finally complete, we may test it on some example program. Please note numbers in comments on the right &ndash; they show actual opcode instruction address, and will be used for conditional jumps and procedure calls.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">const</span> <span class="kt">int</span> <span class="n">fib</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// address of the fibonacci procedure</span>
</span><span class='line'><span class="kt">int</span> <span class="n">program</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// int fib(n) {</span>
</span><span class='line'>    <span class="c1">//     if(n == 0) return 0;</span>
</span><span class='line'>    <span class="n">LOAD</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>       <span class="c1">// 0 - load last function argument N</span>
</span><span class='line'>    <span class="n">CONST_I32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// 2 - put 0</span>
</span><span class='line'>    <span class="n">EQ_I32</span><span class="p">,</span>         <span class="c1">// 4 - check equality: N == 0</span>
</span><span class='line'>    <span class="n">JMPF</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>       <span class="c1">// 5 - if they are NOT equal, goto 10</span>
</span><span class='line'>    <span class="n">CONST_I32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>   <span class="c1">// 7 - otherwise put 0</span>
</span><span class='line'>    <span class="n">RET</span><span class="p">,</span>            <span class="c1">// 9 - and return it</span>
</span><span class='line'>    <span class="c1">//     if(n &lt; 3) return 1;</span>
</span><span class='line'>    <span class="n">LOAD</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>       <span class="c1">// 10 - load last function argument N</span>
</span><span class='line'>    <span class="n">CONST_I32</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>   <span class="c1">// 12 - put 3</span>
</span><span class='line'>    <span class="n">LT_I32</span><span class="p">,</span>         <span class="c1">// 14 - check if 3 is less than N</span>
</span><span class='line'>    <span class="n">JMPF</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>       <span class="c1">// 15 - if 3 is NOT less than N, goto 20</span>
</span><span class='line'>    <span class="n">CONST_I32</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>   <span class="c1">// 17 - otherwise put 1</span>
</span><span class='line'>    <span class="n">RET</span><span class="p">,</span>            <span class="c1">// 19 - and return it</span>
</span><span class='line'>    <span class="c1">//     else return fib(n-1) + fib(n-2);</span>
</span><span class='line'>    <span class="n">LOAD</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>       <span class="c1">// 20 - load last function argument N</span>
</span><span class='line'>    <span class="n">CONST_I32</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>   <span class="c1">// 22 - put 1</span>
</span><span class='line'>    <span class="n">SUB_I32</span><span class="p">,</span>        <span class="c1">// 24 - calculate: N-1, result is on the stack</span>
</span><span class='line'>    <span class="n">CALL</span><span class="p">,</span> <span class="n">fib</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>   <span class="c1">// 25 - call fib function with 1 arg. from the stack</span>
</span><span class='line'>    <span class="n">LOAD</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>       <span class="c1">// 28 - load N again</span>
</span><span class='line'>    <span class="n">CONST_I32</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>   <span class="c1">// 30 - put 2</span>
</span><span class='line'>    <span class="n">SUB_I32</span><span class="p">,</span>        <span class="c1">// 32 - calculate: N-2, result is on the stack</span>
</span><span class='line'>    <span class="n">CALL</span><span class="p">,</span> <span class="n">fib</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>   <span class="c1">// 33 - call fib function with 1 arg. from the stack</span>
</span><span class='line'>    <span class="n">ADD_I32</span><span class="p">,</span>        <span class="c1">// 36 - since 2 fibs pushed their ret values on the stack, just add them</span>
</span><span class='line'>    <span class="n">RET</span><span class="p">,</span>            <span class="c1">// 37 - return from procedure</span>
</span><span class='line'>    <span class="c1">// entrypoint - main function</span>
</span><span class='line'>    <span class="n">CONST_I32</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>   <span class="c1">// 38 - put 6 </span>
</span><span class='line'>    <span class="n">CALL</span><span class="p">,</span> <span class="n">fib</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>   <span class="c1">// 40 - call function: fib(arg) where arg = 6;</span>
</span><span class='line'>    <span class="n">PRINT</span><span class="p">,</span>          <span class="c1">// 43 - print result</span>
</span><span class='line'>    <span class="n">HALT</span>            <span class="c1">// 44 - stop program</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// initialize virtual machine</span>
</span><span class='line'><span class="n">VM</span><span class="o">*</span> <span class="n">vm</span> <span class="o">=</span> <span class="n">newVM</span><span class="p">(</span><span class="n">program</span><span class="p">,</span>   <span class="c1">// program to execute</span>
</span><span class='line'>                   <span class="mi">38</span><span class="p">,</span>    <span class="c1">// start address of main function</span>
</span><span class='line'>                   <span class="mi">0</span><span class="p">);</span>    <span class="c1">// heap to be reserved, fib doesn&#39;t require heap</span>
</span><span class='line'><span class="n">run</span><span class="p">(</span><span class="n">vm</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>As you may have seen, there is a lot of <code>LOAD, -3</code> operations. Why -3? Again, when we perform a procedure call, we need to store current program state on top of the stack. To do so, we&rsquo;ll put here a 3 values: program counter (as return address), frame pointers before the call, and number of arguments to be used by called procedure. Therefore everything below them (-3 and less) will be an actual function arguments saved on the stack. You could optimize it by adding something like <code>LDARG, x</code> opcode.</p>

<h3>Why?</h3>

<p>There are numerous reasons, why developers may want to use intermediate bytecode representations for their languages:</p>

<ul>
<li><strong>Performance</strong> &ndash; as you&rsquo;ve seen, execution of the bytecode is realized mostly by just moving (mostly incrementing) PC pointer. When interpreter works directly by evaluating and traversing an AST tree, there is a lot of pointer jumping and structure blocks, which is slightly more complex and slower. Bytecode allows you to faster code interpretation as well as it may facilitate some optimizations.</li>
<li><strong>Code size</strong> &ndash; full code operates on human readable strings, which may consume some memory and are harder to interpret. Intermediate program representation uses only a simple integer arrays.</li>
<li><strong>Well-fitting</strong> &ndash; since you may describe your own IR, you may fit it directly to your needs. It&rsquo;s easier to parse, and it could remove some repetitive work, when you&rsquo;ll want to implement your language on the various OSes.</li>
</ul>

</div>

</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	<a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
	
	
	<a class="addthis_button_tweet"></a>
	
	
	<a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>



<section id="comment">
    <h1 class="title">Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Bartosz Sypytkowski


Design based on: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
</body>
</html>
