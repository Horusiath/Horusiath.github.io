<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: .net | Simple Solutions]]></title>
  <link href="http://bartoszsypytkowski.com/blog/categories/dot-net/atom.xml" rel="self"/>
  <link href="http://bartoszsypytkowski.com/"/>
  <updated>2015-03-14T13:19:00+01:00</updated>
  <id>http://bartoszsypytkowski.com/</id>
  <author>
    <name><![CDATA[Bartosz Sypytkowski]]></name>
    <email><![CDATA[b.sypytkowski@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[C#] A different look at service design]]></title>
    <link href="http://bartoszsypytkowski.com/blog/2015/02/23/functional-csharp/"/>
    <updated>2015-02-23T00:13:00+01:00</updated>
    <id>http://bartoszsypytkowski.com/blog/2015/02/23/functional-csharp</id>
    <content type="html"><![CDATA[<p>Today I want to present a different point of view on C# applications design. If you are programming in that language most of the time, it&rsquo;s probably not what you&rsquo;re used to see. However I found it interesting, because it allows to achieve a few important goals:</p>

<ul>
<li>Decompose various, complex interfaces into few simpler, well build components.</li>
<li>Seriously reduce risk of common OO anti-patterns in your application i.e. <a href="http://en.wikipedia.org/wiki/God_object">God Object</a>.</li>
<li>Make your code shorter and methods simpler.</li>
<li>Replace a lot of external assembly dependencies in your code with some simple design patterns.</li>
</ul>


<p>If you&rsquo;re ready, prepare to step down to the Wonderland. Let the Catepillar be our guide.</p>

<h3>The basics</h3>

<h4>Step 1 &ndash; define an interface</h4>

<p>Lets start with twisting our mindsets a little bit. Take the following example:</p>

<p>```csharp
public interface IAuthService
{</p>

<pre><code>Task&lt;User&gt; SignUp(string email, string password);
Task&lt;User&gt; SignIn(string email, string password);
Task ResetPassword(string email);
</code></pre>

<p>}
```</p>

<p>This is our new trendy-looking, non-blocking service interface. What&rsquo;s also important here, it follows a <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a>.</p>

<h4>Step 2 &ndash; separate responsibilities</h4>

<p>Since SRP has no well-defined bounds and it is a matter of a personal taste, we could stretch it a little further:</p>

<p>```csharp
public interface ISignInService
{</p>

<pre><code>Task&lt;User&gt; Handle(string email, string password); 
</code></pre>

<p>}</p>

<p>public interface ISingUpService
{</p>

<pre><code>Task&lt;User&gt; Handle(string email, string password); 
</code></pre>

<p>}</p>

<p>public interface IResetPasswordService
{</p>

<pre><code>Task Handle(string email); 
</code></pre>

<p>}
```</p>

<p>Now instead of one service responsible for three possible operations, we have a three atomic services, each one having only one operation to take care off. If you&rsquo;re thinking, it&rsquo;s overly complicated, you&rsquo;re probably right. But right now we&rsquo;re still in Objective Oriented world and the Wonderland awaits ahead.</p>

<h4>Step 3 &ndash; more simplification</h4>

<p>Now, when we have a three single-member services, take a look into the mirror. If you do, you&rsquo;ll notice an important characteristic &ndash; interface with single method is almost indistinguishable from a delegate. It looks better now, see?:</p>

<p><code>csharp
public delegate Task&lt;User&gt; SignUpService(string email, string password);
public delegate Task&lt;User&gt; SignInService(string email, string password);
public delegate Task ResetPasswordService(string email);
</code></p>

<p>At this point you may want to turn back. This design is problematic. For example, it isn&rsquo;t as easily composable with Dependency Injection frameworks as interfaces. Don&rsquo;t worry. We will cover this up later. Now step in.</p>

<h4>Step 4 &ndash; final generalization</h4>

<p>Our service signatures are now almost ready. But to reach behind the mirror, we must apply two more rules:</p>

<ul>
<li>Each service takes no more than one parameter.</li>
<li>Each service should always return a value.</li>
</ul>


<p>Why does it matter? If each service will satisfy one input / one output rule, we may compose them together with ease.</p>

<p><code>csharp
public delegate Task&lt;User&gt; SignUpService(SignUpRequest request);
public delegate Task&lt;User&gt; SignInService(SignInRequest request);
public delegate Task&lt;object&gt; ResetPasswordService(string email);
</code></p>

<p>Now, all of our delegates could be abstracted away to a single generic definition:</p>

<p><code>csharp
public delegate Task&lt;TRep&gt; Service&lt;in TReq, TRep&gt;(TReq request);
</code></p>

<p>where:</p>

<ul>
<li><code>TReq</code> is type of request object passed to service.</li>
<li><code>TRep</code> is type of service reply.</li>
</ul>


<p>What we end up with is a highly abstracted &ndash; in Wonderland things looks different &ndash; and universal service signature.</p>

<h3>Dependency Injection vs partial application</h3>

<p>Walking down the object oriented road, often you could passed a view similar to this one:</p>

<p>```csharp
public class TransportationService
{</p>

<pre><code>private readonly ILocalizationService _localizationService;
private readonly IOrdersRepository _ordersRepository;
private readonly ICustomersRepository _customersRepository;
private readonly IConfigurationProvider _configuration;

public TransportationService (
    ILocalizationService localizationService,
    IOrdersRepository ordersRepository,
    ICustomersRepository customersRepository,
    IConfigurationProvider configuration) 
{
    _localizationService = localizationService;
    _ordersRepository = ordersRepository;
    _customersRepository = customersRepository;
    _configuration = configuration;
}

public async Task&lt;TransportationDetails&gt; PrepareTransportation(int orderId) 
{
    ...
}
</code></pre>

<p>}
```</p>

<p>But now when you&rsquo;re on the other side of the mirror, it looks more like:</p>

<p>```csharp
public static TransportationServices
{</p>

<pre><code>public static Service&lt;int, TransportationDetails&gt; PrepareTransportationService (
    ILocalizationService localizationService,
    IOrdersRepository ordersRepository,
    ICustomersRepository customersRepository,
    IConfigurationProvider configuration)
    {
        return async orderId =&gt; { ... };
    }
</code></pre>

<p>}
```</p>

<p>Here we simply return an asynchronous lambda. And because it&rsquo;s nested inside, it can use all of the provided parameters directly in it&rsquo;s scope.</p>

<p>Of course, there is still a matter of lifetime scopes. In case of singleton scopes, we simply may pass shared instance directly. But when more universal lifetimes are required, we can slide down the road along with the delegates to reach even higher abstractions &ndash; it&rsquo;s twisted, but we&rsquo;re in Wonderland, remember?</p>

<p>```csharp
public static Service&lt;LocalizationRequest, LocalizationReply> LocalizationService() { &hellip; }</p>

<p>public static Service&lt;MyRequest, MyReply> MyService(Func&lt;Service&lt;LocalizationRequest, LocalizationReply>> localizationServiceProvider) { &hellip; }</p>

<p>// transient scope
var myService = MyService(() => LocalizationService());
// or even shorter
var myService2 = MyService(LocalizationService);</p>

<p>// singleton scope
var localizator = LocalizationService();
var myService = MyService(() => localizator);
var myService2 = MyService(() => localizator);
```
There is a one simple but powerful idea visible on the example above &ndash; an input parameter type has been changed from interface to another delegate. Now it&rsquo;s delegates all the way down. This way we may start from the most atomic services and combine them into more complex ones without limitations.</p>

<p>Instead of complex, reflection-based DI frameworks we have one simple universal abstraction. You may find this more verbose, but it&rsquo;s actually simpler, faster and more error-proof solution than any of IoC libraries. You don&rsquo;t need to learn next DI framework or use StackOverflow guide to travel through the Wonderland.</p>

<p>There are other problems solved automatically:</p>

<ul>
<li>No need to worry about cyclic references.</li>
<li>There is no risk, that our DI framework won&rsquo;t know how to bind parameters to construct object. You&rsquo;ll never get a runtime errors when walking this way.</li>
<li>Your application won&rsquo;t inject bad interface implementation by mistake.</li>
</ul>


<h3>Repositories and testing</h3>

<p>Another popular OO desing pattern is a repository and it&rsquo;s most corrupted (and misunderstood) version &ndash; generic repository.</p>

<p>```csharp
public interface IGenericRepository<T>
{</p>

<pre><code>Task&lt;IEnumerable&lt;T&gt;&gt; GetAll();
Task&lt;T&gt; GetById(int id);
Task&lt;T&gt; Create(T entity);
Task&lt;T&gt; Update(T entity);
Task&lt;bool&gt; Delete(T entity);
</code></pre>

<p>}
public interface IUserRepository : IGenericRepository<User> {</p>

<pre><code>Task&lt;User&gt; GetByEmail(string email);
</code></pre>

<p>}
```</p>

<p>Lets be honest &ndash; you&rsquo;ll probably never use all of those methods at once. If you think it&rsquo;s good abstraction, it&rsquo;s not. It isn&rsquo;t a good SRP example either. After we had stepped into the mirror, we&rsquo;ve surely taken something from our world with us. So lets take a one of the things we&rsquo;ve hidden in the pocket &ndash; changing user password.
```csharp
public class UserService
{</p>

<pre><code>private readonly IUserRepository _userRepository;
public UserService(IUserRepository userRepository)
{
    _userRepository = userRepository;
}

public async Task&lt;PasswordChanged&gt; ChangePassword(ChangePassword request)
{
    var user = await _userRepository.FindByEmail(request.Email);
    if(IsValid(user, request.OldPassword))
    {
        user.PasswordHash = ComputePasswordHash(request.NewPassword);
        await userUpdater(user);
        return new PasswordChanged();
    }
    else throw new UnauthorizedException();
}

private byte[] ComputePasswordHash(string password) { ... }
private bool IsValid(User user, string password) { ... }
</code></pre>

<p>}</p>

<p>```</p>

<p>Basically changing password would require only two out of six methods provided by <code>IUserRepository</code> &ndash; matching user and saving his/her state after changing. Now smoke the Catepillar&rsquo;s hookah and take a look again:</p>

<p>```csharp
public static Service&lt;ChangePassword, PasswordChanged> ChangePasswordService(Func&lt;Service&lt;string, User>> userFinderProvider, Func&lt;Service&lt;User, User>> userUpdaterProvider)
{</p>

<pre><code>var userFinder = userFinderProvider();
var userUpdater = userUpdaterProvider();

return async request =&gt; {
    var user = await userFinder(request.Email);
    if (IsValid(user, request.OldPassword))
    {
        user.PasswordHash = ComputePasswordHash(request.NewPassword);
        await userUpdater(user);
        return new PasswordChanged();
    }
    else throw new UnauthorizedException();
};
</code></pre>

<p>}</p>

<p>private static byte[] ComputePasswordHash(string password) { &hellip; }
private static bool IsValid(User user, string password) { &hellip; }
```
We totally dealt with repository interface, introducing two service providers presented before.</p>

<p>Hint:</p>

<blockquote><p>You can turn <code>ComputePasswordHash</code> (or even <code>IsValid</code>) into service on it&rsquo;s own. All hail the modularity!</p></blockquote>

<h4>From testing perspective &hellip;</h4>

<p>In traditional OO world, to test this feature, you&rsquo;d probably include some mocking library, mock repository&rsquo;s interface and check if correct method was called with correct arguments. You may also mock underlying database directly with something like <a href="http://effort.codeplex.com/">Effort</a>.</p>

<p>In Wonderland mocklibs are quite rare creatures. They are even harder to catch. We must find another way. Can we simply test it without <strong>any</strong> mocking library? Lets see:</p>

<p>```csharp
// Arrange:
// if you abstracted ComputePasswordHash earlier, it&rsquo;ll be easier at this point
var testUser = new User(email, passwordHash);
var db = new Dictionary&lt;string, User> { { testUser.Email, testUser } };
Service&lt;string, User> userFinder = async email => {</p>

<pre><code>User user;
return db.TryGetValue(email, out user) ? user : null;
</code></pre>

<p>};
Service&lt;User, User> userUpdater = async user => user;
var changePasswordService = ChangePasswordService(() => userFinder, () => userUpdater);</p>

<p>// Act:
await changePasswordService(new ChangePassword(email, oldPassword, newPassword));</p>

<p>// Assert:
Assert.NotEqual(passwordHash, testUser.PasswordHash);
```
Actually, that&rsquo;s all. Including mock initialization and result verification. No mocklib was harmed in the making of this test.</p>

<h3>Aspect Oriented Programming vs lambda combinators</h3>

<p>If you&rsquo;re still interested in miracles of the Wonderland, we can go further. Next question: how can we bend reflection-based Aspect Oriented Programming to our will? There are possibly many ways, but I&rsquo;ll focus only on the one.</p>

<p>Just like we used services to replace all of our interfaces, we replace aspects / attributes with filters:</p>

<p><code>csharp
public delegate Task&lt;TOut&gt; Filter&lt;in TIn, TOut, out TReq, TRep&gt;(TIn request, Service&lt;TReq, TRep&gt; service);
</code>
where:</p>

<ul>
<li><code>TIn</code> is filter&rsquo;s input type.</li>
<li><code>TOut</code> is filter&rsquo;s output type.</li>
</ul>


<p>Filter is actually a wrapper around specific service, which may apply additional code before or after it, modify it&rsquo;s input or output or even decide not to call it at all. In case when filter don&rsquo;t change service&rsquo;s in / out parameters, it&rsquo;s signature is basically equal to <code>public delegate Task&lt;TRep&gt; Filter&lt;TReq, TRep&gt;(TReq request, Service&lt;TReq, TRep&gt; service);</code>.</p>

<p>Now, having those two types defines, lets create some utility methods, which can make our travel easier. Lets start with filter composer.
```csharp
public static Filter&lt;TIn, TOut, TReq2, TRep2> Then&lt;TIn, TOut, TReq1, TRep1, TReq2, TRep2>(</p>

<pre><code>this Filter&lt;TIn, TOut, TReq1, TRep1&gt; self,
Filter&lt;TReq1, TRep1, TReq2, TRep2&gt; next)
</code></pre>

<p>{</p>

<pre><code>return (request, service) =&gt; self(request, req =&gt; next(req, service));
</code></pre>

<p>}
```
If we omit the method signature, this method is a pretty straightforward one liner which combines two filters together and gives another filter in return. As you can guess, with this trick we can join a whole chains of filters into one piece.</p>

<p>There is a second part of the puzzle missing. We still don&rsquo;t have a well defined methods to work with both filters and services. This is the one:
```csharp
public static Service&lt;TReqIn, TRepOut> ApplyTo&lt;TReqIn, TRepOut, TReqOut, TRepIn>(</p>

<pre><code>this Filter&lt;TReqIn, TRepOut, TReqOut, TRepIn&gt; filter,
Service&lt;TReqOut, TRepIn&gt; service)
</code></pre>

<p>{</p>

<pre><code>return request =&gt; filter(request, service);
</code></pre>

<p>}
```
Just like we were combining filters, now we combine a filter with a service to get service in return.</p>

<p>With this two methods (and basically two lines of code!) we can easily interop between filters and services. How will this weapon examine against aspects?</p>

<p>```csharp
// logging example
public static Filter&lt;TReq, TRep, TReq, TRep> LogFilter&lt;TReq, TRep>(Action<string> logger)
{</p>

<pre><code>return async (request, service) =&gt;
{
    logger("Log before: " + request);
    var reply = await service(request);
    logger("Log after: " + reply);
    return reply;
};
</code></pre>

<p>}</p>

<p>// authorization example
public static Filter&lt;UnauthorizedRequest, TReply, AuthorizedRequest, TReply> AuthorizeFilter<TReply>(</p>

<pre><code>Func&lt;Service&lt;UnauthorizedRequest, Identity&gt;&gt; authorizationServiceProvider)
</code></pre>

<p>{</p>

<pre><code>return async (request, service) =&gt;
{
    var authService = authorizationServiceProvider();
    var authorizedIdentity = await authService(request);
    if (authorizedIdentity != null)
    {
        return await service(new AuthorizedRequest(authorizedIdentity, request));
    }
    else throw new UnauthorizedAccessException();
};
</code></pre>

<p>}</p>

<p>// combine various filters together
var filters = AuthorizeFilter(AuthorizationService)</p>

<pre><code>.Then(LogFilter(Console.WriteLine))
.Then(MonitorFilter(MonitorService)
.Then(UnitOfWorkFilter());
</code></pre>

<p>// apply all filters at once to the service
var enchancedService = filters.ApplyTo(myService);
```</p>

<p>Again, thankfully to the power of composability we can join multiple filters into one and apply them to any number of services we wish to. Basically two simple types and two lines of code compiled upfront!</p>

<p>We ripped off (or seriously reduced) any runtime uncertainties, AOP, DI and mock libraries out of our code, as well as whole bunch of interfaces and abstraction layers. Did you enjoy the travel? Welcome in the Wonderland. Land of functional programming.</p>

<p><strong>PS</strong>: presented concept is heavily inspired by <a href="http://twitter.github.io/finagle/guide/">Finagle</a> library, originally written in Scala on a Twitter&rsquo;s purposes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Things you may not know about CSharp value types]]></title>
    <link href="http://bartoszsypytkowski.com/blog/2014/03/24/things-you-may-not-know-about-csharp-value-types/"/>
    <updated>2014-03-24T22:43:00+01:00</updated>
    <id>http://bartoszsypytkowski.com/blog/2014/03/24/things-you-may-not-know-about-csharp-value-types</id>
    <content type="html"><![CDATA[<p>In this post I&rsquo;ll try to deal with few of the myths lying beneath common understanding of how C# structures works in reality. Many of new .NET acolytes are thought about differences between structs and classes. For easier understanding many of those concepts are simplified and therefore doesn&rsquo;t necessary tell all truth about underlying mechanism.</p>

<p>Here are some of them.</p>

<h1>Structs may not be stack allocated</h1>

<p>Think about following example:
``` csharp
struct MyStruct
{</p>

<pre><code>public int X { get; set; }
</code></pre>

<p>}</p>

<p>public static Func<int> Example1()
{</p>

<pre><code>var a = new MyStruct { X = 3 };
return () =&gt;
{
    Console.WriteLine(a.X);
    return ++a.X;
};
</code></pre>

<p>}
```
As you remember, one of the well known side effects of stack-allocated values is that they&rsquo;re destroyed automatically, when we leave scope, where they were created. This remains true in .NET environment &ndash; it assures that no more but one value or pointer may be found on top of the stack when returning from method execution.</p>

<p>But what happens, when we execute <code>Example1</code> method and then call lambda returned? <code>a</code> variable as stack allocated structure, should be already destroyed at that moment (it&rsquo;s out of it&rsquo;s creation scope and has not been returned explicitly). But that&rsquo;s not what really happens. Actually .NET environment performs an <strong>escape analysis</strong> to determine if any references to that structure didn&rsquo;t leave it&rsquo;s scope. In that case it would be rather heap allocated in order to prevent premature destruction.</p>

<p>Other known case, when structs become heap allocated values, are allocations of large amounts of memory dedicated to handle values. Since stack memory is very limited (by default it&rsquo;s about 1MB per thread on Windows OS), massive structure allocations would potentially cause a StackOverflowException. What .NET environment does in that case, is fallback to safer heap-based allocations.</p>

<p><em>NOTE</em>: Unfortunatelly at the present moment C# doesn&rsquo;t provide escape analysis to determine if class instances could be stack allocated. Java, even though hasn&rsquo;t got custom value types yet, can provide that feature for specific conditions.</p>

<h1>Struct and class method calls differs significantly</h1>

<p>Next exercise. Think about two types, struct and a class. Both of them have non-static method with identical signature and implementation. When you create instances of both types and call mentioned methods, which call will be faster? If you&rsquo;d thought, that struct method call will be slightly faster, you&rsquo;re right. But why?</p>

<p>Answer lies in low level difference between CIL instructions <code>call</code> and <code>callvirt</code>. Standard class methods use <code>callvirt</code> (name is misleading &ndash; it&rsquo;s used even for non-virtual methods). Since CLR cannot absolutely guarantee, if instance method is overridden or shadowed, it has to perform explicit check by seeking class VTable for function pointer. Actual VTable pointer is one of the internal members of each object. Therefore it requires null check to be performed.</p>

<p>Since struct cannot be null, we don&rsquo;t have to perform null checking. However it&rsquo;s not necessary. Since value types cannot declare or override virtual methods &ndash; struct have fixed inheritance chain &ndash; we don&rsquo;t have to access their VTables. Actually lack of inheritance is so useful, that structure instances don&rsquo;t need to have any pointers to VTable at all. All of these save time necessary to perform a method call.</p>

<p>From that perspective struct method calls are much closer to static methods &ndash; also invoked through <code>call</code> instruction &ndash; than instantiated ones.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[O pomyłkach i wnioskach z pracy w ASP.NET MVC]]></title>
    <link href="http://bartoszsypytkowski.com/blog/2013/10/20/o-pomykach-i-wnioskach-z-pracy-w-aspnet/"/>
    <updated>2013-10-20T09:49:00+02:00</updated>
    <id>http://bartoszsypytkowski.com/blog/2013/10/20/o-pomykach-i-wnioskach-z-pracy-w-aspnet</id>
    <content type="html"><![CDATA[<p>O wzorcach projektowych w ASP.NET MVC słyszał chyba każdy. Większość z nas przynajmniej raz widziała jakiś filmik instruktażowy bądź wideokonferencję promującą stosowanie właściwych wzorców na tej platformie. Jednakże po opanowaniu teorii przychodzi wreszcie pora na to, aby wcielić ją w życie. Co się wtedy okazuje? Bardzo często wychodzi na jaw, że zastosowanie poznanych praktyk w prawdziwym życiu sprawia problem, a kolejne miesiące programowania w myśl jakiejś metodyki prowadzą do ostatecznej refleksji będącej zgubą programistów: <em>zrobię cokolwiek byle zadziałało</em>.</p>

<p>W tym poście spróbuję opisać najczęstsze błędy, z którymi przyszło mi się zmierzyć &ndash; również te wynikające z ograniczeń technologii, ale przede wszystkim będące skutkiem niewłaściwego podejścia do problemu.</p>

<h2>Twoja encja ≠ Twój model</h2>

<p>Zasadniczym błędem (lub raczej skrótem myślowym) jest założenie, że każda klasa mapowana przez ORM na tabele może służyć jako model przekazywany bezpośrednio do widoku. Nie znaczy to, że jest to nie możliwe, jednak opcja ta jest z reguły nadużywana. Wynika to poniekąd ze stylu programowania wyuczonego z tutoriali z cyklu &ldquo;wyklep CRUDa w 5 min.&rdquo;. Piękne i proste, jednak nie mające wiele wspólnego z problemami dnia codziennego. Z drugiej strony jest to wina samego lenistwa programistów oraz przeświadczenia, że faza projektowania z rozpiską architektury chociażby na kartce papieru jest tylko dla kobiet i leszczy ;)</p>

<p>Pytanie brzmi: kiedy należałoby porzucić modelowanie z encji na rzecz dedykowanych klas POCO? Prawda jest taka, że zależy to od przypadku i wymaga odrobiny doświadczenia.</p>

<ul>
<li>Jedną z podpowiedzi może być poziom zagłębienia zależności. Im jest on głębszy, tym bardziej wykorzystywana przez nas klasa odbiega strukturą od modelu wymaganego przez widok. Przykładowo już 2 poziom zagłębienia np. <code>Model.Products.SelectMany(p => p.Orders)</code> może świadczyć o tym, że dana encja nie jest właściwym kandydatem i powinna zostać zmapowana na dedykowaną do tego celu klasę.</li>
<li>Innym przykładem może być sytuacja, w której nasz model wykazuje pewien związek z regułami biznesowymi. Przykładowo częstym sposobem reprezentacji okresu czasu powiązanego z danym obiektem jest dodanie do modelu dwóch pól określających granice czasowe. W tym momencie pojawia się jednak pewien dysonans między definicją biznesową (okres czasu jest pojedynczym obiektem) a rzeczywistą implementacją (okres czasu to dwa generyczne pola dat). Jeżeli logika biznesowa silnie bazuje na danej definicji np. przedział czasowy często pojawia się w kontekście wykonywanych operacji, wtedy możliwe, że lepiej byłoby wyodrębnić ją do osobnej klasy.</li>
<li>Jak powszechnie wiadomo, we współczesnym świecie aplikacji WWW wymagania klientów są jednymi z najbardziej zmiennych elementów systemu. Możliwość oddzielenia modeli od encji wspiera ten trend, ponieważ o ile encje są powiązane ze schematem bazy danych (przez co są znacznie mniej podatne na zmiany ze względu na konieczność utrzymania spójności z istniejącymi danymi), o tyle modele wykorzystywane przez nas w aplikacji mogą być swobodnie modelowane do naszych potrzeb.</li>
</ul>


<h2>Twój ViewData = Twój Model</h2>

<p>W przypadku niektórych frameworków model jest zdefiniowany w sposób jasny i jednoznaczny. W przypadku ASP.NET MVC nie jest jednak tak łatwo, ponieważ otrzymujemy tutaj więcej niż jeden sposób dostarczenia danych do widoku. Mowa tu oczywiście o ViewData. Wg. mnie obiekt ten, jakkolwiek przydatny, jest podstawowym złamaniem wzorca MVC w ASP.NET MVC. Dlaczego? Ponieważ &nbsp;prawda wygląda tak, że niezależnie od zdefiniowanych przez ciebie klas, prawdziwy model ma zawsze tylko jeden typ: <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.viewdatadictionary(v=vs.108">ViewDataDictionary</a>.aspx).</p>

<p>Czy to źle? Niekoniecznie, zależy od przyjętego podejścia. Co z tego wynika? W przypadku modeli zwracanych przez formularze zazwyczaj przyjmuje się, że generyczny model powinien zawierać tylko te dane, które zostały wprowadzone przez użytkownika. Tzn. że informacje takie jak opcja wybrana przez użytkownika z listy powinna być częścią modelu podczas gdy sama lista dostępnych opcji powinna być przekazywana za pośrednictwem ViewBag/ViewData. Naturalnie w przypadku, gdy parsujemy model do postaci JSON przekazywanej do klienta, ta zasada nie dotyczy.</p>

<h2>Nic nie znaczące Error Messages</h2>

<p>Jednymi ze gorszych chwil w życiu programisty, są sytuacje, kiedy trzeba obsłużyć zgłoszenie o błędzie w aplikacji. Zdarza się, że zaglądamy wtedy do logów (o ile taką informację zalogowaliśmy ;) ), aby odnaleźć jakieś przydatne informacje, które pozwolą nam zidentyfikować naturę problemu. Jakże wielkie jest rozczarowanie, gdy jedynym hintem jaki wtedy otrzymujemy jest: <code>Object reference not set to an instance of an object.</code> Bardzo rzeczowa i jednoznaczna informacja wśród kilkuset linii kodu wymagających zbadania.</p>

<p>Innym ciężkim przypadkiem jest logowanie niewystarczającej ilości informacji. Przykład (blok try-catch jest czysto poglądowy):
``` c#
try
{</p>

<pre><code>...
var product = productRepository.GetById(id);
if(product.Status != ProductStatus.Finished)
    throw new InvalidStatusException("Provided product has invalid status");
...
</code></pre>

<p>} catch(Exception e) {</p>

<pre><code>    logger.Log(e.Message);
</code></pre>

<p>}
```
Co jest złego w tym przypadku? Wyobraźmy sobie, że dostajemy zgłoszenienie, o błędzie a w logach jedyną informacją jest: <code>Provided product has invalid status</code>. Czy wiemy o jakim statusie mowa? Czy wiemy o jaki produkt chodzi? Nie mamy żadnych informacji pozwalających zidentyfikować dany przypadek, mimo że wszystko co potrzebne mamy 2 linijki wyżej w kodzie źródłowym naszej aplikacji.</p>

<p>Stąd mój apel: nie bądź leniwcem, minuta pracy teraz pozwoli ci zaoszczędzić godziny problemów później.</p>

<h2>Too thin controllers, too fat services</h2>

<p><em>Fat models, thin controllers</em> jest zwrotem często używanym w świecie MVC. Często jednak wynikiem utrzymania tej reguły jest zjawisko, które sam określam jako papierowe kontrolery. Weźmy na przykład następującą akcję MVC:
``` c#
[HttpPost]
public void ToggleUserBan(bool activate)
{</p>

<pre><code>this.userService.ToggleUserBan(activate);
</code></pre>

<p>}
<code>
Na czym polega błąd? Prawdopodobnie metoda ToggleUserBan w serwisie jest przypadkiem zbyt szczegółowym. Daje to podstawy do przypuszczenia, że architektura aplikacji w którymś momencie się posypała. Zajrzyjmy więc do naszego hipotetycznego IUserService:
</code> c#
interface IUserService {</p>

<pre><code>void ToggleUserBan(bool flag);
IEnumerable&lt;User&gt; GetAllUsers();
IEnumerable&lt;User&gt; GetActiveUsers();
IEnumerable&lt;User&gt; GetBannedUsers();
// ...kolejne 70 metod
</code></pre>

<p>}
```
Jeżeli widzisz taki interfejs, wiedz że coś się dzieje. To z czym mamy do czynienia to nic innego, jak zwykłe zamiatanie brudu pod dywan. Pseudorozwiązanie polegające na przeniesieniu proceduralnego makaronu w miejsce, w które rzadziej się zagląda. Jest to częsty rezultat braku rewizji kodu i testów jednostkowych, oraz samowoli programistów.</p>

<h2>Garść innych porad</h2>

<ul>
<li>unikaj static classes &ndash; utrudniają one modularyzację systemu i wprowadzają twarde powiązania, z których bardzo ciężko jest potem zrezygnować. Extension methods są w zasadzie jedynym zastosowaniem dla statycznych klas, dla jakich sam znajduję użytek.</li>
<li>unikaj partial classes &ndash; dopuszczalne tylko w wypadku, gdy rozszerzasz klasę generowaną przez zewnętrzne narzędzia (co swoją drogą samo w sobie jest złym pomysłem ale o tym może kiedy indziej ;) )</li>
<li>w przypadku zmiennych używaj nazw, które pozwalają określić ich typ i przeznaczenie &ndash; różnego rodzaju skróty oszczędzają dosłownie kilka sekund podczas pisania tylko po to, aby w przyszłości przedłużyć rozszyfrowywanie kodu przez kogoś innego o kilka minut. Pamiętaj, że w życiu programisty kod czyta się częściej niż pisze.</li>
<li>podczas zwracania kolekcji zwracaj najmniejszy interface, który umożliwia wykonanie zadania &ndash; nie ma sensu wymagać aby argument był listą, jeżeli jedynym wykonywanym na nim działaniem jest foreach</li>
<li>jeżeli zwracasz string lub kolekcje nigdy nie zwracaj nulli &ndash; zawsze używaj string.Empty lub Enumerable.Empty&lt;></li>
<li>nie sprawdzaj czy enumerator jest pusty przy pomocy Count() &ndash; używaj Any(). W przypadkach kiedy potrzebujesz porównać ilość argumentów w enumeratorze z konkretną liczbą np. list.Count() > 3, warto zastanowić się nad użyciem wzorca <a href="http://twistedoakstudios.com/blog/Post4425_counting-iterators-lazily">LazyCounter</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ServiceStack - alternatywa dla ASP.NET]]></title>
    <link href="http://bartoszsypytkowski.com/blog/2013/08/10/servicestack-alternatywa-dla-aspnet/"/>
    <updated>2013-08-10T20:14:00+02:00</updated>
    <id>http://bartoszsypytkowski.com/blog/2013/08/10/servicestack-alternatywa-dla-aspnet</id>
    <content type="html"><![CDATA[<p>ASP.NET jest wiodącą technologią, jeżeli idzie o rozwiązania webowe w środowisku .NET. I mimo, że pojęcie to samo w sobie nie jest jednolite (w ramach ASP występuje wiele oddzielnych technologii), to jednak niewiele słyszy się o alternatywach. A jest ich całkiem sporo:</p>

<ul>
<li><a href="http://www.servicestack.net/">ServiceStack</a> &ndash; najbardziej znana alternatywa, o której opowiem więcej w dalszej części posta.</li>
<li><a href="http://nancyfx.org/">Nancy</a>&ndash; drugi obok ServiceStack, najbardziej znany framework, czerpiący inspirację ze znanego frameworka Sinatra, napisanego w Rubym.</li>
<li><a href="https://github.com/openrasta/openrasta/wiki/Why-Choose-OpenRasta">OpenRasta</a>&ndash; biblioteka stworzona z myślą o tworzeniu API opartego o zasoby.</li>
<li><a href="http://amirrajan.net/Oak/">Oak</a> &ndash; framework mocno zainspirowany dynamiką bibliotek Ruby.</li>
<li><a href="http://blog.markrendle.net/2012/06/01/simple-web/">Simple.Web</a> &ndash; micro framework twórcy znanego micro ORMa Simple.Data, który umieszczam również w ramach ciekawostki.</li>
</ul>


<p>Sądzę, że dość niewiele osób słyszało te nazwy (zwłaszcza ostatnie dwie). Ja jednak postanowiłem opowiedzieć i zachęcić do najpopularniejszego z tych rozwiązań, czyli ServiceStack.</p>

<p>Co takiego otrzymujemy, decydując się na jego wykorzystanie?:</p>

<ul>
<li>Cały zestaw <em>extension methods</em> do wbudowanych typów .NET, przyspieszających pracę programistów.</li>
<li><a href="https://github.com/ServiceStack/ServiceStack/wiki/Auto-mapping">Mechanizm mapowania obiektów</a> &ndash; podobny do AutoMappera, choć prostszy i bardziej ubogi.</li>
<li><a href="https://github.com/ServiceStack/ServiceStack/wiki/Built-in-profiling">Profiler</a> wbudowany w środowisko.</li>
<li><a href="http://fluentvalidation.codeplex.com/wikipage?title=CreatingAValidator">Zaawansowany mechanizm walidacji</a>, umożliwiający m.in. warunkową walidację poszczególnych pól.</li>
<li>Mechanizm <a href="https://github.com/ServiceStack/ServiceStack/wiki/Authentication-and-authorization">autentykacji</a> i zarządzania dostępem oparty o role i uprawnienia z możliwością logowania poprzez OpenID.</li>
<li><a href="https://github.com/ServiceStack/ServiceStack/wiki/The-IoC-container">Kontener IoC</a> &ndash; również z możliwością podpięcia własnego.</li>
<li>Minimalistyczny framework ORM (<a href="https://github.com/ServiceStack/ServiceStack.OrmLite">OrmLite</a>) &ndash; umożliwia on podłączenie do najpopularniejszych relacyjnych, baz danych. Naturalnie on również może być zastąpiony bardziej kompleksowym rozwiązaniem.</li>
<li>Wiązania do rózniej maści usług logowania (np. NLog, Elmah, Log4Net, EventLog, Enterprise Lib.) i cache'owania (np. domyślny InMemory, Memcached, Redis, Azure lub Amazon Web Services).</li>
<li>Bundlera plików JavaScript, CSS, LESS, SASS i CoffeeScript &ndash; chociaż trzeba przyznać, że jest to dość wyboista droga.</li>
<li>Mechanizm do kolejkowania wiadomości &ndash; obecnie tylko za pośrednictwem Redisa. Trwają prace nad wprowadzeniem bindingów do ZeroMQ, RabbitMQ, Azure Service Bus oraz Amazon SQS.</li>
<li>Gotowe SDK do aplikacji klienckich pod C#, Silverlight, JavaScript oraz Dart.</li>
</ul>


<p>Ale mówiąc o jego najbardziej kompleksowych zaletach:</p>

<h2>Web services &amp; Content Negotiation</h2>

<p>Jest to &ndash; moim zdaniem &ndash; najciekawsza cecha Service Stack. Tworząc dotychczasowe usługi sieciowe z wykorzystaniem standardowych bibliotek .NET musieliśmy uzależniać technologię, jaką zamierzaliśmy wykorzystać od formatu danych, jakiego się spodziewaliśmy. A więc tworząc serwisy wykorzystujące SOAP lub XML tworzyliśmy dla nich specjalne usługi w WCFie. Jeżeli chcielibyśmy, aby zwracały one dane w postaci JSON, prawdopodobnie większość z nas wykorzystałaby najnowsze podejście w postaci ASP.NET Web API, dla pozostałych formatów ASP.NET.</p>

<p>Problemem takiego podejścia jest fakt, że za każdym z tych rozwiązań stoi osobna technologia, która nie jest kompatybilna z pozostałymi. Niezależnie od tego, co wybierzemy, nigdy nie otrzymamy kompletnego rozwiązania.</p>

<p>Jak wygląda to w przypadku ServiceStack? To proste. Każdy z modułów naszej aplikacji może być zamknięty w ramach klas dziedziczących po wspólnej klasie <code>Service</code>(jednak wbrew pozorom nie mamy tu do czynienia z wzorcem MVC) &ndash; lub w razie potrzeby, którejś z jej klas bazowych bądź interfejsu <code>IService</code>. Każda metoda obsługująca żądanie pobiera w parametrze obiekt POCO (Plain Old Class Object) i zwraca inny obiekt POCO. Dopiero na poziomie frameworka rozwiązywany jest problem serializacji danego obiektu do końcowego formatu, który może być wnioskowany na podstawie nagłówka HTTP, zawartości URL bądź dowolnego innego warunku, jaki zdefiniujemy podczas konfiguracji. Rozwiązanie to znane jest jako <em>Content Negotiation</em>. Dzięki temu jedna klasa może pełnić rolę kontrolera ASP.NET, WebAPI i serwisu WCF w tym samym czasie!</p>

<p>Domyślnie dysponujemy wbudowanymi serializatorami dla formatów: SOAP (1.1 oraz 1.2), XML, JSON, CSV i JSV. Dodatkowo w sieci można pobrać pluginy rozszerzające tą listę o niemal wszystkie formatery dostępne w świecie .NET, w tym też binarne. Jedna linijka kodu w konfiguracji nieraz wystarcza, aby wprowadzić dany format do naszej aplikacji. Warto zauważyć, że ta sama zasada panuje w przypadku dynamicznie generowanych stron HTML &ndash; po doinstalowaniu pluginu możemy generować strony w oparciu o składnię Razora oraz Markdown.</p>

<h2>Wydajność</h2>

<p>Twórcy ServiceStack zwracają szczególną uwagę na szybkość swojej platformy, w myśl powiedzenia: <i>&ldquo;We care about two things: speed and quality. And the quality we care about is speed&rdquo;</i>. Nie powinno więc dziwić, że większości wypadków framework ten przewyższa ASP.NET i WCF w kwestiach wydajnościowych. Wynika to z prostego faktu. Mamy tu do czynienia z inicjatywą open source, a w przedsięwzięciach tego typu dużą rolę odgrywa prostota. Nie ma tutaj miejsca na platformy typu Enterprise, z setkami warstw abstrakcji, pełnymi potworków typu <a href="http://ws.apache.org/xmlrpc/apidocs/org/apache/xmlrpc/server/RequestProcessorFactoryFactory.RequestSpecificProcessorFactoryFactory.html">RequestSpecificProcessorFactoryFactory</a>(tak, jest to wyraz mojego &ldquo;hejtu&rdquo; względem podejścia projektowego w Javie, ale fakt faktem problem ten dotyka również .NETu ;) ).</p>

<p>Konkretne porównania i benchmarki można znaleźć <a href="https://github.com/ServiceStack/ServiceStack/wiki/Real-world-performance">tutaj</a>. I jak widać, nie chodzi tu o jakiś pomijalny zysk rzędu kilkunastu procent.</p>

<h2>Testowalność</h2>

<p>ServiceStack jest frameworkiem z natury bardzo zmodularyzowanym, umożliwiającym wymianę poszczególnych komponentów. To z kolei czyni go naturalnym kandydatem do wprowadzenia testów jednostkowych.</p>

<p>Innym atutem jest podejście wymiany danych opartych na komunikatach (message-based design), które w wypadku ServiceStack są zwykłymi klasami POCO. Dzięki temu testując poszczególne moduły/usługi nie musimy przetwarzać wbudowanych we framework obiektów żądań i odpowiedzi. Zamiast tego mamy do czynienia ze standardowym zbiorem klas, zdefiniowanych przez nas samych, które z zewnątrz nie zdradzają zależności od używanego przez nas frameworka. Ponad to architektura sprawia, że najwygodniejszym podejściem jest budowa dużej ilości serwisów z małą ilością metod, co dodatkowo ułatwia zachowanie ziarnistości systemu.</p>

<h2>Wieloplatformowość</h2>

<p>Ostatnią wartą odnotowania cechą pozostaje fakt, że wybierając SS otrzymujemy w pełni funkcjonalny framework działający zarówno pod Windowsem jak i platformami linuxowymi. Wiem, że pod ASP również można programować w sposób pozwalający na postawienie aplikacji na Linuxie, ale jest to rozwiązanie niekompletne. Przykładowo, ServiceStack jest obecnie jedyną opcją pozwalającą na uruchomienie usług SOAP pod Mono.</p>

<p>Nie oznacza to jednak, że decydując się na SS, musimy rezygnować z naszej dotychczasowej aplikacji napisanej w ASP.NET. Równie dobrze możemy uruchomić hosta ServiceStack wewnątrz Global.asax i używać go np. tylko jako zamiennika warstwy nośnej dla usług WCF.</p>

<p>Całość doskonale wpisuje się w naturę technologii webowych, ich otwartość i multiplatformowość. Dodatkowo umożliwia ona optymalizację kosztów (hosting linuxowy jest średnio 5-krotnie tańszy niż porównywalny windowsowy) i otwiera nowe możliwości na rynku, który w przypadku .NET w ogromnej części składa się z aplikacji biznesowych.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Czego programiści .NET mogliby nauczyć się od Rubystów?]]></title>
    <link href="http://bartoszsypytkowski.com/blog/2013/06/16/czego-programisci-net-mogliby-nauczyc/"/>
    <updated>2013-06-16T12:28:00+02:00</updated>
    <id>http://bartoszsypytkowski.com/blog/2013/06/16/czego-programisci-net-mogliby-nauczyc</id>
    <content type="html"><![CDATA[<p>.NET był wybraną przeze mnie technologią niemal od początku mojej przygody z programowaniem. Uważam jednak, że programista nie powinien się zamykać w jednej szyfladce i poznawać szerokie spectrum technologii. Porównywać je i znać wady oraz zalety każdej z nich. Ostatecznie zaś umieć dobrać właściwą technologię do rozwiązania napotykanych problemów &ndash; nie odwrotnie ;)</p>

<p>Stąd też pytanie w temacie. Czy faktycznie programiści .NET mogą nauczyć się czegoś ze środowiska Ruby, języka, który ostatnimi czasy zbiera niemało batów (głównie związanych z wydajnością oraz bezpieczeństwem jego najpopularniejszej platformy, RoRa)? Otóż jak się okazuje całkiem sporo, nawet pomimo już istniejącego trendu absorbowania do platformy .NET sporej ilości rozwiązań napotykanych w konkurencyjnych gałęziach. Poniżej postaram się wymienić te, które moim zdaniem są warte odnotowania.</p>

<h2>1. Przestań polegać na swoim IDE</h2>

<p>Nie da się tego ukryć &ndash; Visual Studio jest jednym z najlepszych, o ile nie najlepszym IDE, z jakim programista może mieć obecnie przyjemność pracować. Ma to jednak pewną cenę. W pewnym momencie zaczynamy polegać na swoim IDE w stopniu większym, niż na własnych umiejętnościach. Co gorsza przenosi się to bezpośrednio na tworzone biblioteki (przykład&hellip; Entity Framework &ndash; czy ktoś próbował kiedyś stworzyć model edmx bez pomocy wizarda wbudowanego w Visual Studio?). Jeżeli nie możesz sprawnie korzystać z biblioteki bez wsparcia swojego IDE, oznacza to, że jest ona zbyt skomplikowana i najzwyczajniej w świecie zepsuta.</p>

<p>W przypadku Ruby'ego, narzędzie pracy jest kwestią gustu. Jednakże kiedy pierwszy raz przyszło mi pracować z teamem RoR każde z nich w porównaniu do Visual Studio wygląda jak notatnik z kolorowaniem składni. Żadnego zaawansowanego refactoringu, intellisense, nawigacji między plikami w projekcie, generowania buildów. Co było w tym najzabawniejsze? Po 2 tygodniach wcale mi tego nie brakowało. Przysłowiowy notatnik + konsola całkowicie wystarczały do pracy, zaś narzędzia są skonstruowane tak, aby programista był sobie w stanie poradzić ze wszystkim zaraz po zainstalowaniu interpretera.</p>

<h2>2. Debuger jest opcją, nie obowiązkiem</h2>

<p>W świecie .NET jest to dziwna opinia. Wielu programistów wykorzystuje go jako normalne narzędzie pracy służące sprawdzeniu, czy aplikacja działa poprawnie. Dodatkowo sam Visual Studio ułatwia takie podejście. Jako programista Ruby nigdy nie musiałem skorzystać z debuggera &ndash; prawdę mówiąc, nigdy go nie zainstalowałem. Nie oznacza to oczywiście, że kod napisany w Rubym jest zawsze właściwy. Wynika to z innego podejścia. W tym środowisku standardem jest pisanie unit testów do weryfikacji każdej bardziej złożonej części systemu. Dzięki temu testy w Rubym są domyślnym <strong>must have</strong> przy każdym projekcie.</p>

<h2>3. Nie bój się eksperymentować</h2>

<p>To co najbardziej spodobało mi się we współpracy z programistami Ruby, to otwartość na nowinki, chęć wypróbowania innych podejść. Wiąże się z tym pewne ryzyko, ale również określony zysk. Tutaj powstaje pewien problem &ndash; ryzyko w skostniałym świecie aplikacji biznesowych z reguły jest czymś nie do przyjęcia. Dodatkowym hamulcem jest tutaj fakt, że wielu starszych programistów ze środowiska .NET nieprzychylnie patrzy na rozwiązania open source (w końcu kogo wtedy pociągnąć do odpowiedzialności?) oraz ogólnie technologiom spoza kółka Microsoftu.</p>

<p>Nie należy bać się zmian. Nawet jeżeli ryzyko jest nieakceptowalne w aplikacjach dla klientów zewnętrznych, wciąż możemy wprowadzać drobne zmiany dla systemów używanych wewnątrz firmy oraz wypróbowywać tam nowe podejścia. Z jednej strony może to przełożyć się na zysk w przyszłości, z drugiej działa to jak magnes na programistów-pasjonatów, a takich nigdy nie ma za wielu, prawda? ;)</p>
]]></content>
  </entry>
  
</feed>
