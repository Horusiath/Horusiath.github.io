<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: akka.net | Simple Solutions]]></title>
  <link href="http://bartoszsypytkowski.com/blog/categories/akka-dot-net/atom.xml" rel="self"/>
  <link href="http://bartoszsypytkowski.com/"/>
  <updated>2015-03-18T19:17:09+01:00</updated>
  <id>http://bartoszsypytkowski.com/</id>
  <author>
    <name><![CDATA[Bartosz Sypytkowski]]></name>
    <email><![CDATA[b.sypytkowski@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Akka.NET remote deployment with F#]]></title>
    <link href="http://bartoszsypytkowski.com/blog/2014/12/14/fsharp-akka-remote-deploy/"/>
    <updated>2014-12-14T13:43:00+01:00</updated>
    <id>http://bartoszsypytkowski.com/blog/2014/12/14/fsharp-akka-remote-deploy</id>
    <content type="html"><![CDATA[<p>Today I want to present how Akka.NET can be used to leverage distributed computing and discuss some of the changes in the latest F# package (Akka.FSharp 0.7.1). If you are not interested in explanation of how Akka.NET internals actually allow us to create distributed actor-based application, just skip the next part and dive directly into examples.</p>

<h3>How Akka.NET remote deployment works</h3>

<p>When a new actor should be created, it&rsquo;s actor system deployer have to figure out if deployment should occur on local machine or on the remote node. Second option requires a network connection to be established between local/remote nodes participating in the communication. To be able to do so, each participating node needs to know a localization of the others. In Akka, this is done by using actor paths.</p>

<p>Actor path allows us to identify actors in scope of their systems actor hierarhies as well as localize them over the network. There are two formats of actor paths, both of them uses standard URI convention:</p>

<ol>
<li>Local paths (eg. <code>akka://local-system/user/parent/child</code>) may be used to identify actors deployed (remotely or not) by our local actor system, we are referring to. In provided example actor path refers to actor with name <code>child</code>, which parent/supervisor actor is called <code>parent</code>, which resides under <code>user</code> guardian (which is a specialized actor supervisor existing inside actor system kernel). All of them exists in actor system named <code>local-system</code>.</li>
<li>Remote paths (eg. <code>akka.tcp://remote-system@localhost:9001/</code>) are similar to local ones, but a few differences occur. First we need to rename <code>akka</code> protocol to either <code>akka.tcp</code> or <code>akka.udp</code> to show what kind of underlying network connection we want to target. Second we have to suffix actor system name with it&rsquo;s localization. This is done by providing address and port, remote node is expected to listening on.</li>
</ol>


<p>Image below shows how actually actors refer to each other in remote deployment scenario.</p>

<p><img src="http://i61.tinypic.com/vpknkh.png" width=840 style="display: block; margin-left: auto; margin-right: auto" /></p>

<p>When an actor is deployed remotely, a remote node is responsible for creating it&rsquo;s instances, but we still refer to it using it&rsquo;s actor reference and our local system context. Local/remote coordination is done by remote daemon &ndash; specialized system actor, which resides directly under <code>/remote</code> path of the system root. With example above we may refer to remotely deployed child using <code>akka.tcp://sys@A:2552/user/parent/child</code> address, while it&rsquo;s true hierarchy lays under <code>akka.tcp://sys@B:2552/remote/sys@A:2552/user/parent/child</code> path. This allows us to preserve location transparency, hiding true underlying actor. References returned this way all almost indistinguishable from their local counterparts, allowing use of features such as monitoring, supervising and so on.</p>

<h3>Remote deployment</h3>

<h4>Hocon configuration</h4>

<p>To start playing with remote deployment, we should configure both endpoints to be able to maintain network communication. This is achievable through the <a href="https://github.com/typesafehub/config/blob/master/HOCON.md">HOCON</a> configuration, which is the default format for both JVM and .NET Akka implementations. While you may be a little irritated by need of learning new format only to use Akka, remember:</p>

<ol>
<li>It&rsquo;s actually very easy to learn</li>
<li>It&rsquo;s not XML ;)</li>
</ol>


<p>Before continue, I encourage you to get yourself familiar with it.</p>

<p>To enable remote deployment feature, this would be a minimal Akka.NET configuration setup:
```
akka {</p>

<pre><code>actor {
    provider = "Akka.Remote.RemoteActorRefProvider, Akka.Remote"
}
remote.helios.tcp {
    port = 9001
    hostname = localhost
}
</code></pre>

<p>}
<code>``
First, every configuration node resides under common root called</code>akka<code>. Since remoting is not default feature of Akka.NET, we have to inform our actor system how to couple remotely deployed actors with our local actor system. This setup is done through</code>RemoteActorRefProvider<code>defined under</code>akka.actor.provider` config node. It will allow us to associate references to spawned actors on both local and remote systems.</p>

<p>Next one is <code>remote</code> node which defines configuration specific to remoting feature. There, we need to inform how our system will communicate with others. At the present moment it&rsquo;s achievable using <a href="https://github.com/Aaronontheweb/helios">Helios</a> server by default, which is lightweight and highly-concurrent TCP/UDP server developed by Aaron Stannard, one of the Akka.NET core developers &ndash; don&rsquo;t confuse it with Microsoft Helios, which is totally different project. Akka.Remote will use it automatically under the hood &ndash; the only thing we have to define is address and port, under which it will listen for incoming messages. If you want port to be resolved automatically, just set 0 as the port number.</p>

<p>Excluding differences in system nodes localization, this configuration string may be shared by both local and remote node. You may use this configuration simply by parsing it using <code>Configuration.parse</code> function.</p>

<h3>Let&rsquo;s get to the point</h3>

<p>Unlike the C#, F# API is able to construct actors using expressions compiled directly at the runtime (while still providing type safety, F# programmers are used to have). It&rsquo;s achievable by leveraging <a href="http://msdn.microsoft.com/en-us/library/dd233212.aspx">F# quotations</a>, which can be serialized and compiled on demand on other machine.</p>

<p>For the sample we don&rsquo;t need to have two separate machines, instead we may mock them by running two Akka applications. What is necessary for the most basic example, is that both of them have to share at least Akka.FSharp and Akka.Remote assemblies as well as all of their dependencies.
<code>powershell
install-package Akka.FSharp -version 0.7.1
install-package Akka.Remote -version 0.7.1
</code></p>

<h4>Remote node</h4>

<p>The only job of the remote system is to listen for incoming actor deployment requests and execute them. Therefore implementation is very simplistic:
```fsharp
let config =</p>

<pre><code>Configuration.parse 
    @"akka {
        actor.provider = ""Akka.Remote.RemoteActorRefProvider, Akka.Remote""
        remote.helios.tcp {
            hostname = localhost
            port = 9001
        }
    }"
</code></pre>

<p>[<EntryPoint>]
let main args =</p>

<pre><code>use system = System.create "remote-system" config
System.Console.ReadLine()
0
</code></pre>

<p>```
After running it our remote system should be listening on localhost on port 9001 and be ready to instantiate remotely deployed actors.</p>

<h4>Local actor system instance</h4>

<p>Second application will be used for defining actors and sending deployment requests to remote node. To do so it has to know it&rsquo;s address.</p>

<p>To deploy our actors remotely, lets build some helper functions. To begin with, write some logic to inform our local system, that deployment should occur on the remote machine. Remember that we need to provide full address to the remote system including it&rsquo;s network localization and protocol type used for communication.
<code>fsharp
open Akka.Actor
// return Deploy instance able to operate in remote scope
let deployRemotely address = Deploy(RemoteScope (Address.Parse address))
</code>
Remote deployment in Akka F# is done through <code>spawne</code> function and it requires deployed code to be wrapped into F# quotation.
```fsharp
let spawnRemote systemOrContext remoteSystemAddress actorName expr =</p>

<pre><code>spawne systemOrContext actorName expr [SpawnOption.Deploy (deployRemotely remoteSystemAddress)]
</code></pre>

<p>```
Quotations give us a few nice features, but also have some limitations:</p>

<ol>
<li>Unlike the C# approach, here we don&rsquo;t define actors in shared libraries, which have to be bound to both endpoints. Actor logic is compiled in the runtime, while remote actor system is operating. That means, there is no need to stop your remote nodes to reload shared actor assemblies when updated.</li>
<li>Code embedded inside quotation must use only functions, types and variables known to both endpoints. There are limited ways to define functions inside quotation expression (and no way to define types), but generally speaking in most cases it&rsquo;s better to define them in separate library and share between nodes.</li>
</ol>


<p>Last line of the <code>spawne</code> function is list of options used to configure actor. We used <code>SpawnOption.Deploy</code> to specify what deployment specifics are meant to occur. Other options may describe specifics such as message mailboxes, actor routers or failure handling strategies.</p>

<p>Because Akka actor system is required to negotiate deployment specifics with external nodes, it&rsquo;s local instance has to be provided even thou we want to deploy our actors on the remote machines.</p>

<p>Finally when everything is set, we can run our example (remember that remote node must be up and running):
```fsharp
let system = System.create &ldquo;local-system&rdquo; config
let aref =</p>

<pre><code>spawnRemote system "akka.tcp://remote-system@localhost:9001/" "hello" 
    // actorOf wraps custom handling function with message receiver logic
    &lt;@ actorOf (fun msg -&gt; printfn "received '%s'" msg) @&gt;
</code></pre>

<p>// send example message to remotely deployed actor
aref &lt;! &ldquo;Hello world&rdquo;</p>

<p>// thanks to location transparency, we can select
// remote actors as if they where existing on local node
let sref = select &ldquo;akka://local-system/user/hello&rdquo; system
sref &lt;! &ldquo;Hello again&rdquo;</p>

<p>// we can still create actors in local system context
let lref = spawn system &ldquo;local&rdquo; (actorOf (fun msg &ndash;> printfn &ldquo;local &lsquo;%s&rsquo;&rdquo; msg))
// this message should be printed in local application console
lref &lt;! &ldquo;Hello locally&rdquo;
```
As a result, you should receive two messages printed in <strong>remote application console</strong> and one locally. See?</p>

<p><img src="http://www.reactiongifs.com/r/mgc.gif" style="display: block; margin-left: auto; margin-right: auto" /></p>

<h3>Final thoughts</h3>

<p>Remember that Akka.NET is still in beta and all of the F# API functions are subject to change. If you have some concepts or interesting ideas, or want to help and become part of the family, you may share them on <a href="https://groups.google.com/forum/?utm_medium=email&amp;utm_source=footer#!forum/akkadotnet-user-list">Akka.NET discussion group</a> or directly on <a href="https://github.com/akkadotnet/akka.net">Github</a>.</p>

<h3>Appendix A: set your configuration string in application config file</h3>

<p>While you may define configuration strings in code, the better idea is to actually store them in .config files. To be able to do so, we must simply extend configuration file with custom Akka config section:
```xml
<configSections></p>

<pre><code>&lt;section name="akka" type="Akka.Configuration.Hocon.AkkaConfigurationSection, Akka" /&gt;
</code></pre>

<p></configSections>
<code>
Next, we can embed our Hocon-formated configuration string directly into configuration file by using `&lt;![CDATA[]]&gt;` marker (directly under main `&lt;configuration&gt;` root node):
</code>xml
<akka></p>

<pre><code>&lt;hocon&gt;
  &lt;![CDATA[
    ... paste your config string here
  ]]&gt;
&lt;/hocon&gt;
</code></pre>

<p></akka>
<code>``
To load the configuration, simply call</code>Akka.Configuration.ConfigurationFactory.Load()` method.</p>

<h3>Appendix B: Share-nothing</h3>

<p>Since keeping actual assemblies in sync over all of the remote nodes may feel cumbersome for some people, I decided to show a little trick, which may be used to replace some of the complex data structures in your F# code. Lets look how data structure problem may be simply solved in Akka predecessor, Erlang:
```erlang
go() &ndash;></p>

<pre><code>Pid = spawn(RemoteNode, loop),
Pid ! {hello, "world"},
Pid ! {hi}.
</code></pre>

<p>loop() &ndash;></p>

<pre><code>receive
    {hello, Msg} -&gt; 
        io:fwrite("hello ~p~n", [Msg]),
        loop();
    {hi} -&gt;
        io:fwrite("hi~n"),
        loop()
end.
</code></pre>

<p><code>``
I think, that based on your knowledge about functional programming, most of it should be at least familiar if not self-explanatory. Crux is the</code>{hello, Msg}<code>and</code>{hi}` syntax &ndash; these are actually instances of tuples (nested into pattern matched message receiver construct). Standard Erlang convention precises them as so called tagged tuples, which first argument is an <strong>atom</strong> &ndash; also known as symbol in other languages. Since Erlang is a dynamic language, this way we may differentiate tuples of the same size from each other.</p>

<p>Example below shows how usage of the Erlang&rsquo;s tagged tuples could be moved into F#. The big difference is that F# has no Erlang <strong>atom</strong> equivalent. Therefore they has been replaced by F# literal integers, which gives us an advantage of human readable tags, while still counted as integers inside quotation expressions.
```fsharp
[<Literal>]let Hello = 1
[<Literal>]let Hi = 2</p>

<p>let pid = spawne system &ldquo;remote&rdquo; (&lt;@ fun mailbox &ndash;></p>

<pre><code>    let rec loop() : Cont&lt;obj, obj&gt; = actor {
        let! msg = mailbox.Receive()
        match msg with
        | (Hello, str) -&gt; printfn "hello %A" str
        | (Hi) -&gt; print "hi\n"
        | _ -&gt; mailbox.Unhandled()
        return! loop()
    }
    loop() @&gt;) [SpawnOption.Deploy Deploy(RemoteScope(Address.Parse remoteAddr))]
</code></pre>

<p>pid &lt;! (Hello, &ldquo;world&rdquo;)
pid &lt;! (Hi)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hipsterize your backend for The Greater Good with Akka.NET, F# and some DDD flavor]]></title>
    <link href="http://bartoszsypytkowski.com/blog/2014/10/26/akka-fsharp-ddd/"/>
    <updated>2014-10-26T22:54:00+01:00</updated>
    <id>http://bartoszsypytkowski.com/blog/2014/10/26/akka-fsharp-ddd</id>
    <content type="html"><![CDATA[<p>Initially this post was supposed to cover concepts of implementing an example DDD (Domain Driven Design) architecture using F# and Akka.NET. But the more I&rsquo;ve written, the more I&rsquo;ve realized that whole idea won&rsquo;t fit into a single blog post. Therefore I&rsquo;ve decided for now to focus on some basic example covering command/event handlers. To make this more interesting I want to show how Akka.NET and F# features can be used to leverage design established this way.</p>

<h3>Before we begin&hellip;</h3>

<p>I want to notice, that all examples in this post are made mostly to learning purposes. There are some things missing, but I&rsquo;ve decided to leave them since they don&rsquo;t have direct impact on the overall design or current state of the application. If I will continue this thread, I will probably try to extend them and provide some more meaningful context. So please don&rsquo;t treat this code as a real-life reference of DDD implementation.</p>

<p>What is clearly missing in example below? I didn&rsquo;t describe aggregate roots, because boundary context is very simplistic &ndash; to make this post clearer I&rsquo;ve focused more on command-handler-event pattern. Sample doesn&rsquo;t enforce any specific database, using simple dictionary as abstraction. Also it doesn&rsquo;t provide any form of data validation or bindings to existing HTTP server frameworks. They are outside of scope of this post but are very simple to integrate.</p>

<h4>Step 1: Define our domain data structures</h4>

<p>Lets start with domain model. As a boundary context I&rsquo;ve chosen one of the most generic ones &ndash; user account&rsquo;s space. Our simplified business logic in this example will cover two actions &ndash; user registration and sign in. Users will be identified by their email and will use the most basic security features.</p>

<p>But before we move there, lets use some of the features, F# could give us, to shape a type system for our advantage.
<code>fsharp
type Email = string
type PasswordHash = byte array
</code>
These are examples of type aliases. You may consider using them, if you&rsquo;ve found that usage of some primitive type in given context may be defined as subtype/supertype relation. In this example Email can be considered as a specialization of string &ndash; that means, each email is string, but not each string is a valid email. This kind of granularity can be stretched quite far. Just think about any primary/foreign key field in any entity as it&rsquo;s own unique type. This will automatically disallow mistakes such as assigning keys from entities of incompatible type eg. assigning <code>UserId</code> value to <code>ProductId</code> field! F# expressiveness promotes this behavior.</p>

<p>Now use these types to define our User entity. It&rsquo;s very straightforward:
```fsharp
type User =</p>

<pre><code>{ email : Email
  phash : PasswordHash
  salt  : byte array }
static member empty =  { email = ""; phash = [||]; salt = [||] }
</code></pre>

<p><code>
Next I'm going to describe data models for our domain commands and events. It's important to understand purpose of both. Commands are produced to describe tasks to be executed by the system and contains all data necessary to perform it. Events are describing diffs in general application state as a results of performed tasks. What is wort mentioning, events should be described in way, that will allow us to recreate current application state by replaying all events timeline stream. And because events describe changes, that already occurred, they should be immutable by nature - don't try to change your past if you not wish to mess with your future.
</code>fsharp
type UserCommand =</p>

<pre><code>| RegisterUser of email : Email * password : string
| LoginUser of email : Email * password : string
</code></pre>

<p><code>
NOTE: If you want to use F# records to describe your commands/events, that's perfectly fine. I've chosen discriminated unions for their expressiveness.
</code>fsharp
type UserEvent =</p>

<pre><code>| UserRegistered of email : Email * salt: byte array * phash : byte array * timestamp : DateTime
| UserLogged of email : Email * timestamp : DateTime
</code></pre>

<p>```
As you can see there are few things worth of emphasizing:</p>

<ul>
<li>We didn&rsquo;t store user password provided directly from command, using salt + password hash instead. Reason behind is that in DDD events usually could be serialized and stored in some kind of event database. Therefore it&rsquo;s not secure to provide them any sensitive data. However events should contain enough information to give us ability to recreate current database state based on provided stream of events, assuming that it&rsquo;s complete.</li>
<li>Each of our event&rsquo;s contain a timestamp field. Events give us a historical change set of the application. And because they contain only diffs between database states rather than snapshot of entities, they have to be ordered by their creation date. Without it we couldn&rsquo;t recreate them.</li>
</ul>


<p>What other fields may be useful when working with events? Consider attaching current API version number &ndash; this will allow you to endure breaking changes in your code responsible for handling events. Other handy field is unique event id, when you may need functionality associated with generating cascading event chains in response to some other events. In that case having some kind of pointer to originating event may be useful.</p>

<h3>Step 2: describe application behavior in functional manner</h3>

<p>This may be a little controversial statement, but I must say it &ndash; exceptions are bad. They leaves the leaks in your type system and fucks with your application logic flow in the way, that many programmers and almost all compilers cannot understand.</p>

<p>The alternative conception of error handling is old and well-known. It&rsquo;s based on returning error codes. To start with &ndash; if you already know <a href="http://www.rust-lang.org/">Rust</a>, this may look familiar to you:
```fsharp
type Result&lt;&lsquo;ok, 'err> =</p>

<pre><code>| Ok of 'ok
| Error of 'err
</code></pre>

<p>```
You may ask: why the hell do we return error values instead of just throwing exceptions? Are these some archaeological excavations and we&rsquo;re gone back to the C era? Actually no. There is very good reason behind this.</p>

<p>Think about exceptions as a side effects of the application state behavior. You cannot be 100% sure about flow of your application process. Since information about exceptions is not part of any function/method signature, they actually act as a dynamically typed cascading return values anyway &ndash; both compiler and programmers will ignore them until they will occur at runtime.</p>

<p>This time instead of cryptic error codes returned by C, we use F# power to provide type-safe and expressive way for this solution. If you&rsquo;re interested more about interesting ways to utilize return-based error handling using higher-level concepts, I recommend you <a href="http://fsharpforfunandprofit.com/posts/recipe-part2/">Railway Oriented Programming</a> blogpost and video presented on NDC Oslo 2014. Here, I&rsquo;ll use a greatly simplified version, exposing operator which chain two input functions together and call second one only if result from the first was <code>Ok</code>, and forwarding an <code>Error</code> result otherwise:</p>

<p>```fsharp
let (>=>) f1 f2 arg =</p>

<pre><code>match f1 arg with
| Ok data -&gt; f2 data
| Error e -&gt; Error e
</code></pre>

<p>```</p>

<p>I&rsquo;ve also decided to use more discriminated unions to describe each specific business logic error in actual bounded context scope. I&rsquo;ve found that returning a string-based messages back to programmers in error logs are not better in any way than creating a specialized error type for each case. The only disadvantage is amount of code you need to write, to declare new type, but again &ndash; it&rsquo;s not a problem with F#.
```fsharp
type UserError =</p>

<pre><code>| UserAlreadyExists of userEmail : Email
| UserNotFound of userEmail : Email
| WrongPassword of userEmail : Email * hashedInput : PasswordHash
</code></pre>

<p>```</p>

<h3>Step 3: handle user registration</h3>

<p>How does F# command handling differs from it&rsquo;s more objective oriented counterpart? Since we deal with functional oriented language, most of our logic is composed into functions instead of objects. You&rsquo;ve used to execute your logic with services, here you&rsquo;ve got a function. Wanna some Dependency Injection? Here, you have some currying.</p>

<p>I&rsquo;ll describe our service as <code>handle</code> function which takes some <code>UserCommand</code> as an input and produces <code>Result&lt;UserEvent, UserError&gt;</code> as output:
```fsharp
let handle clock findUser saveUser =</p>

<pre><code>function 
| RegisterUser(email, password) -&gt; 
    match findUser email with
    | Some _ -&gt; Error(UserAlreadyExists email)
    | None -&gt; 
        let salt, phash = defaultGeneratePassword password            
        let user = 
            { email = email
              salt = salt
              phash = phash }
        saveUser user
        Ok (UserRegistered(email, salt, phash, clock()))
</code></pre>

<p>```
As you&rsquo;ve seen, this function actually takes 4 parameters (clock, findUser, saveUser and command as implicit argument of calling <strong>function</strong> keyword). But as I&rsquo;ve said, our handle function should take only one input argument. That&rsquo;s because we&rsquo;ll provide three first arguments through partial function application later &ndash; now you can think about them as constructor arguments injected by your IoC container when resolving new service.</p>

<p>While most of the parameters are quite understandable, one of them may be confusing &ndash; the <code>clock</code> parameter. It&rsquo;s only functionality is to provide current DateTime value. If so, why didn&rsquo;t I just used <code>DateTime.Now</code> directly inside the code? In this example it&rsquo;s actually not so important, but I&rsquo;ve used it to expose simple problem &ndash; things such as date/configuration/environment providers or random number generators could make our handler behavior non-deterministic. That means, if we call this function two times with the same input, we couldn&rsquo;t count on the same output. It&rsquo;s actually problem for logic predictability and in some cases is especially cumbersome when writing tests to verify application behavior. Therefore I think that it&rsquo;s better to separate them as injectable arguments.</p>

<h4>Password hashing and generation</h4>

<p>While you may find some good libraries providing real life hashing features out of hand, I&rsquo;ve decided to leave my example free on unnecessary dependencies and use a standard library instead.</p>

<p>```fsharp
let private saltWith salt (p : string) =</p>

<pre><code>let passBytes = System.Text.Encoding.UTF8.GetBytes p
Array.append passBytes salt
</code></pre>

<p>let sha512 (bytes : byte array) =</p>

<pre><code>use sha = System.Security.Cryptography.SHA512.Create()
sha.ComputeHash bytes
</code></pre>

<p>let hashPassword hashFn salt password = hashFn (saltWith salt password)</p>

<p>let generatePassword hashFn saltSize password =</p>

<pre><code>use saltGen = System.Security.Cryptography.RandomNumberGenerator.Create()
let salt = Array.zeroCreate saltSize
saltGen.GetBytes salt
(salt, hashPassword hashFn salt password)
</code></pre>

<p>let inline defaultGeneratePassword pass = generatePassword sha512 64 pass
let inline defaultHashPassword salt pass = hashPassword sha512 salt pass
```
I hope this code doesn&rsquo;t need any explanations.</p>

<h3>Step 4: handle user logging</h3>

<p>Once we already described nuances of the function-based services, this one shouldn&rsquo;t be a problem. This case was created to give our example more diversity.
```fsharp
let handle clock findUser saveUser =</p>

<pre><code>function 
| RegisterUser(email, password) -&gt; ...
| LoginUser(email, password, remember) -&gt; 
    match findUser email with
    | None -&gt; Error(UserNotFound email)
    | Some user -&gt; 
        let computedPasswordHash = defaultHashPassword (user.salt) password
        if computedPasswordHash = user.phash then 
            Ok (UserLogged(user.email, clock()))
        else Error(WrongPassword(user.email, computedPasswordHash))
</code></pre>

<p>```</p>

<h4>Mock database access</h4>

<p>As I&rsquo;ve said in the introduction, I won&rsquo;t use any real-life database provider, mocking it with concurrent dictionary instead. However if you want to use a normal database, nothing stands in your way.
```fsharp
let userStore = ConcurrentDictionary()</p>

<p>let inline flip f x y = f y x
let findInUserStore email (store : ConcurrentDictionary&lt;string, User>) =</p>

<pre><code>match store.TryGetValue email with
| (false, _) -&gt; None
| (true, user) -&gt; Some user
</code></pre>

<p>let saveInUserStore user (store : ConcurrentDictionary&lt;string, User>) =</p>

<pre><code>store.AddOrUpdate(user.email, user, System.Func&lt;_, _, _&gt;(fun key old -&gt; user)) |&gt; ignore
</code></pre>

<p>```
F# is heavily function-oriented and this also corresponds to arguments precedence. While in OOP subject (<strong>this</strong>) usually precedes method invocation, in functional languages it&rsquo;s better to use it as last argument of the function. Argumentation for this is currying and partial function application, which allows us to define functions with only part of all necessary arguments provided. The more specific argument, the later it could be applied. Therefore common convention is to provide more detailed parameters at the end of the function parameters list. It&rsquo;s a very useful feature, especially when combined with pipeline operators.</p>

<p>On the other side <code>flip</code> function may be used to reverse parameters precedence in case when, for example, we want to partially apply second argument to the function without providing first one (because it may be yet unknown in this moment). This option will be presented later.</p>

<h4>Handle event subscribers</h4>

<p>One of the nice things in Akka is that it provides a Publish/Subscribe pattern offhand. As an actor-based framework, the only necessary task to do is to subscribe an <code>ActorRef</code> of desired observer directly to Akka system&rsquo;s event stream.</p>

<p>As a lazy person I don&rsquo;t want to be forced to explicitly create new actor each time I want to subscribe some behavior to react for events I&rsquo;ve produced somewhere else. Therefore I&rsquo;ve created simple subscribe helper, which will handle subscriber actor creation for me.
```fsharp
// automatic unique concurrent name generator
let mutable subscriptionNr = 0
let inline getSubNr() = System.Threading.Interlocked.Increment(&amp;subscriptionNr)</p>

<p>let subscribe system (fn : &lsquo;a &ndash;> unit) =</p>

<pre><code>let subId = getSubNr()
let subscriber = spawn system ("subscriber-" + (string subId)) &lt;| actAs fn
system.EventStream.Subscribe(subscriber, typeof&lt;'a&gt;) |&gt; ignore
subscriber
</code></pre>

<p>let publish (bus : Akka.Event.EventStream) evt =</p>

<pre><code>bus.Publish evt
Ok evt
</code></pre>

<p>```</p>

<h3>Bind everything together</h3>

<p>Now when all logic has been defined, it&rsquo;s time to show it in some example code. It will initialize a new Akka system, setup console logging and show features of successful and unsuccessful registering and signing in of the user.
```fsharp
let inline defaultClock() = DateTime.Now
// display any errors returned by command handler
let handleErrors = function</p>

<pre><code>| Ok _ -&gt; ()
| Error data -&gt; printf "User error: %A\n" data
</code></pre>

<p>let system = System.create &ldquo;system&rdquo; &lt;| Akka.Configuration.ConfigurationFactory.Default()
let userHandler =</p>

<pre><code>// inject "dependencies" into handle function
handle 
&lt;| defaultClock 
&lt;| flip findInUserStore userStore 
&lt;| flip saveInUserStore userStore
</code></pre>

<p>let subscriber = subscribe system &lt;| printf &ldquo;User event: %A\n&rdquo;
let userActor = spawn system &ldquo;users&rdquo; &lt;| actorOf (userHandler >=> (publish system.EventStream) >> handleErrors)</p>

<p>userActor &lt;! RegisterUser(&ldquo;<a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#106;&#x2e;&#x64;&#111;&#101;&#x40;&#x74;&#x65;&#115;&#116;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;">&#x6a;&#46;&#x64;&#111;&#101;&#x40;&#x74;&#101;&#x73;&#x74;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;</a>&rdquo;, &ldquo;pass&rdquo;)
userActor &lt;! RegisterUser(&ldquo;<a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#106;&#x2e;&#100;&#111;&#x65;&#64;&#116;&#101;&#115;&#x74;&#x6d;&#97;&#105;&#108;&#x2e;&#x63;&#111;">&#x6a;&#46;&#x64;&#111;&#101;&#x40;&#116;&#101;&#x73;&#116;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;</a>&rdquo;, &ldquo;pass&rdquo;)  // UserAlreadyExists error
System.Threading.Thread.Sleep 100</p>

<p>userActor &lt;! LoginUser(&ldquo;<a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#106;&#x2e;&#100;&#x6f;&#101;&#64;&#x74;&#x65;&#115;&#116;&#x6d;&#97;&#x69;&#108;&#46;&#99;&#111;">&#106;&#46;&#x64;&#x6f;&#x65;&#64;&#x74;&#x65;&#x73;&#116;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;</a>&rdquo;, &ldquo;pass&rdquo;)
userActor &lt;! LoginUser(&ldquo;<a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#106;&#x2e;&#100;&#111;&#101;&#64;&#116;&#101;&#x73;&#x74;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;">&#x6a;&#46;&#100;&#x6f;&#101;&#64;&#116;&#101;&#x73;&#116;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;</a>&rdquo;, &ldquo;fails&rdquo;)     // WrongPassword error</p>

<p>System.Threading.Thread.Sleep 100
system.Shutdown()
```</p>

<p>That&rsquo;s all. Whole example took about 130 lines of F# code to create. I hope this would give you some insights about embedding your business logic into F# function composition model.</p>

<p>PS: If you&rsquo;re interested in more details about DDD and F# programming, at the present moment I can recommend you following other exploring lecture of the other developers, such as Lev Gorodinski (<a href="https://twitter.com/eulerfx">@eulerfx</a>) and his blog for more advanced concepts.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Actor supervisors in Akka.NET FSharp API]]></title>
    <link href="http://bartoszsypytkowski.com/blog/2014/08/06/fsharp-akkadotnet-supervisors/"/>
    <updated>2014-08-06T18:49:00+02:00</updated>
    <id>http://bartoszsypytkowski.com/blog/2014/08/06/fsharp-akkadotnet-supervisors</id>
    <content type="html"><![CDATA[<p>This post will describe changes, that will affect a F# API for Akka.NET in the incoming versions of the framework (>= 0.62) &ndash; mostly those, which concerns supervisioning and manipulating actor hierarchies.</p>

<p>I don&rsquo;t want to overload this post with explaining what Akka supervision is all about, so I&rsquo;ll just recommend a very good article, which could be found <a href="https://github.com/akkadotnet/akka.net/wiki/Supervision">here</a>.</p>

<p>While previous versions of the Akka F# API introduced some nice features such as function-based actor definitions and creations (<code>spawn</code> function), there still was no simple way to handle some core framework concepts. Remember that march towards Akka.NET 1.0 is still in progress, more and more features are implemented. Therefore it&rsquo;s F# API most likely will also be a subject to change.</p>

<p>To give a better description of the new features, lets see an example:</p>

<p>```fsharp
let strategy =</p>

<pre><code>Strategy.oneForOne (fun e -&gt; 
    match e with
    | :? ArithmeticException -&gt; Directive.Resume
    | :? ArgumentException -&gt; Directive.Stop
    | _ -&gt; Directive.Escalate)
</code></pre>

<p>let supervisor =</p>

<pre><code>spawnOpt system "master" (fun mailbox -&gt; 
    // by using spawn we may create a child actors without exiting a F# functional API
    let worker = spawn mailbox "worker" workerFun

    let rec loop() = 
        actor { 
            let! msg = mailbox.Receive()
            match msg with
            | Respond -&gt; worker.Tell(msg, mailbox.Sender())
            | _ -&gt; worker &lt;! msg
            return! loop()
        }
    loop()) [ SupervisorStrategy(strategy) ]
</code></pre>

<p>```
A <a href="https://github.com/akkadotnet/akka.net/blob/dev/src/examples/FSharp.Api/Supervisioning.fs">whole example</a> is available inside Akka.NET project source code, along with other examples.</p>

<p>Unlike standard <code>spawn</code>, <code>spawnOpt</code> function could take a list of options used to configure spawned actor internals. SupervisorStrategy is one of them. By using F# API you are able to use <code>Strategy</code> module to quickly create a corresponding strategy instance. It supports two types of strategy creators:</p>

<ol>
<li><code>Strategy.oneForOne</code> &ndash; strategy will affect only an exception thrower.</li>
<li><code>Strategy.allForOne</code> &ndash; strategy result will propagate to all children of the actor implementing that strategy.</li>
</ol>


<p>Both functions come in two variants. First one takes only one argument &ndash; <em>decider</em> function, which determines an expected behavior based upon type of exception thrown. Second one (<code>Strategy.oneForOne2</code> and <code>Strategy.allForOne2</code>) precedes decider argument with a timeout and number of possible behavior retries. All of them corresponds directly to standard Akka strategy API, but are wrapped to fit F# functional approach instead of method overrides.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Map reduce with FSharp and Akka.net]]></title>
    <link href="http://bartoszsypytkowski.com/blog/2014/07/09/fsharp-akka-map-reduce/"/>
    <updated>2014-07-09T00:00:00+02:00</updated>
    <id>http://bartoszsypytkowski.com/blog/2014/07/09/fsharp-akka-map-reduce</id>
    <content type="html"><![CDATA[<p>In my previous post, I&rsquo;ve shown how to create a simple <em>hello world</em> application using Akka.net system leveraged with a F# API. Today, I&rsquo;ll show a slightly more complex example. We&rsquo;ll create a simple Map-Reduce system based on distributed word count algorithm.</p>

<p>Idea of our algorithm is quite simple &ndash; we want to group and count all repetitions of the same words (case-insensitive) in input text. This is a perfect subject to illustrate a map-reduce algorithm as well as Akka.net task distribution mechanism. To realize our objective, we&rsquo;ll need to define three actor types:</p>

<ul>
<li>Master &ndash; it&rsquo;s main job is to spread an input data equally among other actors and forward request for result data.</li>
<li>Mappers &ndash; they will tokenize their text fragments into specific words and send it to reducers.</li>
<li>Reducers &ndash; they are responsible for word grouping and counting.</li>
</ul>


<p>At the beginning, lets define basic message types used by our system:</p>

<ul>
<li>One to propagate chunks of data to mapping nodes.</li>
<li>Next one to forward processed data to reducers.</li>
<li>Last one to invoke collection mechanism, which will concatenate all reduced data to one peace and send it back to the originator.</li>
</ul>


<p>All of them are illustrated by the code below:
``` fsharp
type MRMsg =</p>

<pre><code>| Map of string
| Reduce of (string * int) list
| Collect
</code></pre>

<p>```</p>

<p>As you may have seen previously, instead of C#/Scala objective approach, I&rsquo;ve used tail-recursive function to define an actor processing routine. Since a lot of it&rsquo;s code would be repetitive among all of the actor types we want to define we can wrap actor behavior using <code>actorOf</code> and <code>actorOf2</code> functions.</p>

<p>Lets start to defining a map-reduce logic into our application. Firstly we need to create a <strong>map actor</strong>. In this example, all what it needs to do, is to chop provided string into single words, and create from them a simple bag of words with their repetition. However we won&rsquo;t sum them now &ndash; this is the job for reducer actors.
``` fsharp
let mapWords (line:string) = seq { for word in line.Split() &ndash;> (word, 1) }</p>

<p>let map reducer (mailbox:Actor<MRMsg>) = function</p>

<pre><code>| Map line -&gt; reducer &lt;! Reduce (mapWords line |&gt; List.ofSeq)
| m -&gt; mailbox.Unhandled m      // mapper won't handle any other messages
</code></pre>

<p>```
As you may see, after finishing it&rsquo;s work, mapper will send list of words directly to reducers. To make this possible, we need to provide reducer reference as one of the function parameters.</p>

<p>Next type is the <strong>reduce actor</strong>. It&rsquo;s task is to group all incoming words, and count their occurrences. In our example we use shared <code>ConcurrentDictionary</code> for gathering data from all of the reducer instances. For more real life example, we should probably use some more sophisticated mechanism, such as <strong>aggregate actor</strong> concatenating all results provided by specific reducers. Here for sake of simplicity, we omit it.
``` fsharp
let reduceWords (dict:ConcurrentDictionary&lt;string,int>) iter =</p>

<pre><code>iter
|&gt; List.iter (fun (k, v) -&gt; dict.AddOrUpdate(k, v, System.Func&lt;_,_,_&gt;(fun key old -&gt; old + v)) |&gt; ignore)
</code></pre>

<p>let reduce (dict:ConcurrentDictionary&lt;string,int>) (mailbox:Actor<MRMsg>) = function</p>

<pre><code>| Reduce l -&gt; reduceWords dict l |&gt; ignore
| Collect -&gt; mailbox.Sender() &lt;! seq { for e in dict -&gt; (e.Key, e.Value) }
| m -&gt; mailbox.Unhandled m
</code></pre>

<p>```
Since reducer actors have direct access to shared dictionary, they also are able to respond on Collect command, providing all reduced data back to message sender.</p>

<p>The last behavior, is the <strong>master actor</strong>. It&rsquo;s role is to be a proxy between application&rsquo;s in/out data, and the rest of the actors. We use it for two tasks: 1) sending text line by line to be processed by our Map-Reduce application, 2) forwarding request for result of MR operation.
``` fsharp
let master mapper (reducer:InternalActorRef) (mailbox:Actor<MRMsg>) = function</p>

<pre><code>| Map str -&gt; for line in str.Split '\n' do mapper &lt;! Map line
| Collect -&gt; reducer.Tell(Collect, mailbox.Sender())    // forward message with info about it's originator
| m -&gt; mailbox.Unhandled m
</code></pre>

<p>```</p>

<p>Now when we have all of our actors defined, we may initialize an Akka framework to create our MR system. Now we can use a helper functions, we&rsquo;ve defined before for fast and easy actor definition.
<code>fsharp
let system = System.create "MapReduceSystem" &lt;| ConfigurationFactory.Default()
let dict = ConcurrentDictionary&lt;string,int&gt;()
let reducer = spawn system "reduce" &lt;| actorOf2 (reduce dict)
let mapper = spawn system "map" &lt;| actorOf2 (map reducer)
let master = spawn system "master" &lt;| actorOf2 (master mapper reducer)
</code></p>

<p>To finalize, we can pass some data to our system to see, if it returns an expected results. Until now, we&rsquo;ve only used send operator <code>&lt;!</code> to delegate fire-and-forget messages for specific actors, but we&rsquo;ve actually never used any two way request-response mechanism. To do so, we&rsquo;ll use Ask method (shortcut operator <code>&lt;?</code>) to send a request message and receive a handler to be used when a response will be returned in asynchronous manner.
``` fsharp
master &lt;! Map &ldquo;Orange orange apple&rdquo;
master &lt;! Map &ldquo;cherry apple orange&rdquo;</p>

<p>Threading.Thread.Sleep 500</p>

<p>// read the result
async {</p>

<pre><code>let! res = master &lt;? Collect
for (k, v) in res :?&gt; (string*int) seq do
    printfn "%s\t%d" k v
system.Shutdown()
</code></pre>

<p>} |> Async.RunSynchronously
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FSharp and Akka.net - the functional way]]></title>
    <link href="http://bartoszsypytkowski.com/blog/2014/07/05/fsharp-akka-net/"/>
    <updated>2014-07-05T21:42:00+02:00</updated>
    <id>http://bartoszsypytkowski.com/blog/2014/07/05/fsharp-akka-net</id>
    <content type="html"><![CDATA[<p>Actor model is one of the most influential paradigms of dealing with highly concurrent environments in present world. Simplifying, it&rsquo;s based on concept of autonomous thread-safe computation units &ndash; surprisingly called actors &ndash; with no way to directly interfere with each others work. There are no locks or semaphores &ndash; instead of accessing shared resources, they are simply passing messages around &ndash; according to the saying <em>Don&rsquo;t communicate by sharing memory; share memory by communicating</em>.</p>

<p>The first most widespread usage of the actor model was the Erlang Virtual Machine in 1986. While it was for many years closed in it&rsquo;s own niche, programming model itself has been lately forwarded and adopted on the Java Virtual Machine through <a href="http://akka.io/">Akka</a> framework. Until present moment there are actually none mature equivalents on .NET platform. While Microsoft is still developing it&rsquo;s own response in form of <a href="http://research.microsoft.com/en-us/projects/orleans/">Project Orleans</a>, a bunch of developers took the initiative of porting Akka on .NET ground.</p>

<p>I&rsquo;ve decided to try out Akka.NET a little. I&rsquo;ve noticed that it&rsquo;s still a far from completion or production-ready phase, but hopefully since it&rsquo;s based on already existing and mature framework, with help of OSS community missing holes could be patched soon.</p>

<h2>Hello Akka</h2>

<p>You can find an original first step into Akka.NET with F# API <a href="https://github.com/akkadotnet/akka.net/wiki/FSharp-API">here</a>. While I found this sample useful, I&rsquo;ve decided to investigate more about Akka.NET source code and it&rsquo;s F# API. Below you may see my example based on more functional-specific concepts:</p>

<p>``` fsharp
type ActorMsg =</p>

<pre><code>| Greet of string
| Hi
</code></pre>

<p>let system = System.create &ldquo;MySystem&rdquo; &lt;| ConfigurationFactory.Default()
let greeter =</p>

<pre><code>spawn system "Greeter" 
&lt;| fun mailbox -&gt;
    let rec loop() = actor {
        let! msg = mailbox.Receive()
        match msg with
        | Greet name -&gt; printfn "Hello %s" name
        | Hi         -&gt; printfn "Hi"
        return! loop() }
    loop()
</code></pre>

<p>greeter &lt;! Greet &ldquo;Alex&rdquo;
greeter &lt;! Hi
```</p>

<p>Here are some explanations:</p>

<ul>
<li>We defined a discriminated union of messages <code>ActorMsg</code>, we want to respond to.</li>
<li>The next step is to create an <code>ActorSystem</code>, analogously to C# and original Scala versions.</li>
<li>We need to define and instantiate an <code>Actor</code>. However unlike the object approach &ndash; which required a custom actor type inheriting from one of the Akka actor classes and defining it&rsquo;s own receiving method &ndash; here we define a tail recursive function, which uses an <code>actor { ... }</code> computation expression instead of actor type declaration.</li>
<li>We pass that function through the lambda to <code>spawn</code> method, which attaches that behavior to our system and returns an <code>ActorRef</code> (not to be confused with Actor instance), assigned to our <code>greeter</code> variable. This way we may refer to actors, and pass messages to them, even if they&rsquo;re not present on our local machine (which is also one of the Akka use cases).</li>
<li>In the last to lines we simply send two messages to actor reference using tell operator <code>&lt;!</code>.</li>
</ul>


<p>As you can see, this piece of code is not directly translatable to C# or even Scala API equivalent. It&rsquo;s much more Erlangish. We don&rsquo;t have to define any classes and method overrides. Instead, we have a tail-recursive function. For me this seems more natural approach for F#, since it&rsquo;s more functional-first language, while it&rsquo;s syntax for object oriented programming is very verbose and ugly.</p>
]]></content>
  </entry>
  
</feed>
