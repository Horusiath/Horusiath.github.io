
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>Simple Solutions</title>
	<meta name="author" content="Bartosz Sypytkowski">

	
	<meta name="description" content="Mar 24th, 2011 .net, bazy danych, programowanie Comments Pobieranie Dużych Zbiorów W Entity Framework Siedząc dzisiaj w pracy natknąłem się na &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Simple Solutions" type="application/atom+xml">
	
	<link rel="canonical" href="http://bartoszsypytkowski.com/blog/page/5/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	

<script type="text/javascript">
      var disqus_shortname = 'bartoszsypytkowski';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


  
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-47294845-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><h1 id="profile-name"><a href="/">Bartosz Sypytkowski</a></h1>
<div class="profilepic">
	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("b.sypytkowski@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
	
</div>

<nav id="main-nav"><ul class="main">
    <li><a href="/">Blog</a></li>
    <li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:b.sypytkowski@gmail.com" title="Email">Email</a>
		
		
		
			<a class="google" href="https://plus.google.com/b.sypytkowski@gmail.com" rel="author" title="Google+">Google+</a>
		
		
			<a class="twitter" href="http://twitter.com/horusiath" title="Twitter">Twitter</a>
		
		
			<a class="github" href="https://github.com/horusiath" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		
		
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2011-03-24T19:48:00+01:00" data-updated="true" itemprop="datePublished">Mar 24<span>th</span>, 2011</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/dot-net/'>.net</a>, <a class='category' href='/blog/categories/bazy-danych/'>bazy danych</a>, <a class='category' href='/blog/categories/programowanie/'>programowanie</a>


</div>
		
			<span class="comments"><a href="/blog/2011/03/24/pobieranie-duzych-zbiorow-w-entity/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2011/03/24/pobieranie-duzych-zbiorow-w-entity/" itemprop="url">Pobieranie Dużych Zbiorów W Entity Framework</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Siedząc dzisiaj w pracy natknąłem się na pewien problem. Otóż spotkałem się z koniecznością pobrania wierszy z bazy i zapisania jej w pliku. Problem w zasadzie trywialny, lecz kiedy mówimy o konieczności zapisania kilkuset tysięcy wierszy, nie jest już tak łatwo. Żadne standardowe odwołanie nie zda tutaj egzaminu, ponieważ wcześniej czy później nasz program zapełni całą dostępną pamięć.</p>

<p>Znajomy polecił mi wykorzystać funkcjonalność, jaką dostarczają metody Skip i Take, dostępne w LINQ. Dzięki nim możemy w prosty sposób podzielić przetwarzaną przez nas bazę na mniejsze fragmenty, które następnie przetwarzamy.</p>

<p>Poniżej przedstawiam przykładowy kod rozwiązania:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="n">using</span><span class="p">(</span><span class="n">Entities</span> <span class="n">context</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Entities</span><span class="p">())</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="kt">var</span> <span class="n">package</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">count</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>          <span class="c1">// licznik</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">resolution</span> <span class="p">=</span> <span class="m">1000</span><span class="p">;</span>  <span class="c1">// &quot;rozmiar&quot; paczki</span>
</span><span class='line'>   <span class="k">do</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="n">package</span> <span class="p">=</span> <span class="p">(</span><span class="k">from</span> <span class="n">d</span> <span class="k">in</span> <span class="n">context</span><span class="p">.</span><span class="n">Data</span>
</span><span class='line'>                       <span class="k">select</span> <span class="n">d</span><span class="p">).</span><span class="n">OrderBy</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">)</span>
</span><span class='line'>              <span class="p">.</span><span class="n">Skip</span><span class="p">(</span><span class="n">count</span><span class="p">).</span><span class="n">Take</span><span class="p">(</span><span class="n">resolution</span><span class="p">).</span><span class="n">ToArray</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">count</span> <span class="p">+=</span> <span class="n">resolution</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">package</span><span class="p">.</span><span class="n">Lenght</span> <span class="p">==</span> <span class="n">resolution</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Jak widać rozwiązanie jest proste. Sądze, że jedyne co wymaga wyjaśnienia, to wykorzystanie OrderBy. Jest to potrzebne, ponieważ ponieważ stałe pomijanie (metoda Skip) pewnych elementów kolekcji wymaga jej poprzedniego posortowania.</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2011-03-10T23:45:00+01:00" data-updated="true" itemprop="datePublished">Mar 10<span>th</span>, 2011</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/dot-net/'>.net</a>, <a class='category' href='/blog/categories/programowanie/'>programowanie</a>, <a class='category' href='/blog/categories/silverlight/'>silverlight</a>


</div>
		
			<span class="comments"><a href="/blog/2011/03/10/silverlight-parametry-inicjalizacyjne-w/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2011/03/10/silverlight-parametry-inicjalizacyjne-w/" itemprop="url">Silverlight - Parametry Inicjalizacyjne W HTML</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>W dzisiejszym poście opiszę krótko obsługę parametrów inicjalizacyjnych w aplikacjach silverlight znajdujących się na naszych stronach. Stanowią one wygodny sposób przekazywania pewnych wartości do aplikacji, gdyż jesteśmy w stanie zapisać je już na poziomie kodu html. Ale do rzeczy.</p>

<p>Jeżeli przeglądaliście kiedyś stronę html z osadzoną na niej kontrolką silverlight, na pewno zauważyliście, że wewnątrz znaczników object zdefiniowane mamy różne parametry aplikacji. Wśród tych wygenerowanych domyślnie mamy m.in:</p>

<ul>
<li><strong>source</strong> &ndash; określa położenie pliku .xap zawierającego aplikację silverlight</li>
<li><strong>onerror</strong> &ndash; określa reakcję na wystąpienie błędu w aplikacji</li>
<li><strong>background</strong> &ndash; określa domyślny kolor tła</li>
</ul>


<p>Są oczywiście jeszcze inne, my skupimy się jednak na wykorzystaniu parametrów inicjalizacyjnych (<strong>InitParams</strong>). Ich sposób zapisu w kodzie html wygląda następująco:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">&quot;InitParams&quot;</span> <span class="na">value=</span><span class="s">&quot;key1=value1,</span>
</span><span class='line'><span class="s">      key2=value2,</span>
</span><span class='line'><span class="s">      key3=value3,</span>
</span><span class='line'><span class="s">      key4=value4&quot;</span> <span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ponieważ wszystkie nazwy parametrów są znaczące, nazwa name musi zawierać wartośc <strong>InitParams</strong>. Dzięki niej nasza aplikacja rozpozna, że ma do czynienia z odpowiednim typem parametrów, które będziemy mogli obsłużyć. Atrybut <strong>value</strong> parametru zawiera serię par klucz-wartość oddzielonych przecinkami, które potem będziemy w stanie odczytać i odpowiednio zapisać w naszej kontrolce.</p>

<p>Teraz kiedy wykonalismy, co należało po stronie html, należy przejść do kodu po stronie aplikacji. Należy pamiętać, że zapisana przez nas lista par nie zostaje zapisana automatycznie w aplikacji. W rzeczywistości pary te zapisane są we właściwości <strong>InitParams</strong> obiektu <strong>StartupEventArgs</strong>, który jest przekazywany przez zdarzenie Startup aplikacji. Wydaje się to trochę zagmatwane, dlatego przejdźmy do rzeczy. Otwieramy plik <strong>App.xaml.cs</strong> (plik z kodem aplikacji, nie kontrolki użytkownika). W konstruktorze klasy dodajemy linijkę:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">this</span><span class="p">.</span><span class="n">Startup</span> <span class="p">+=</span> <span class="k">this</span><span class="p">.</span><span class="n">Application_Startup</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ma tu miejsce oczywiście niejawne przypisanie delegata obsługującego metodę <strong>Application_Startup</strong> do zdarzenia <strong>Startup</strong> obiektu klasy <strong>App</strong> (który dziedziczy to zdarzenie po swojej klasie bazowej <strong>Application</strong>). Dalej opisujemy działanie powyższej metody:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">private</span> <span class="k">void</span> <span class="nf">Application_Startup</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">StartupEventArgs</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>   <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">InitParams</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">para</span> <span class="k">in</span> <span class="n">e</span><span class="p">.</span><span class="n">InitParams</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>              <span class="k">this</span><span class="p">.</span><span class="n">Resources</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">para</span><span class="p">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">para</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="c1">//poniższy kod jest generowany automatycznie</span>
</span><span class='line'>   <span class="k">this</span><span class="p">.</span><span class="n">RootVisual</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MainPage</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Jak widać wpierw pobieramy tu pary klucz-wartość (dokładnie te same które zdefiniowaliśmy wewnątrz atrybutu <strong>value</strong> parametru <strong>InitParams</strong> w kodzie html), a następnie zapisujemy je wewnątrz słownika <strong>Resources</strong> aplikacji. Stąd będziemy mieli do nich prosty dostęp. Aby nasza silverlight&#8217;owa kontrolka była w stanie pobrać te wartości, wystarczy wpisać poniższą linijkę wewnątrz naszej aplikacji:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="kt">var</span> <span class="k">value</span> <span class="p">=</span> <span class="n">App</span><span class="p">.</span><span class="n">Current</span><span class="p">.</span><span class="n">Resources</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Value</strong> stanowi wartość zwracaną przez słownik dla danego klucza <strong>key</strong>. Jak się okazało, wykorzystanie parametrów inicjalizacyjnych jest proste i pozwala na przejżyste przekazywanie wartości za pośrednictwem kodu html.</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2011-03-01T19:58:00+01:00" data-updated="true" itemprop="datePublished">Mar 1<span>st</span>, 2011</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/xml/'>xml</a>


</div>
		
			<span class="comments"><a href="/blog/2011/03/01/transformata-xsl/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2011/03/01/transformata-xsl/" itemprop="url">Transformata XSL</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>W dzisiejszym poście przedstawię problem, z którym przyszło mi się ostatnio zmierzyć. Miałem do wykonania proste zadanie &ndash; Musiałem dokonać transformacji danych z jednego pliku XML na inny plik XML za pomocą stworzonego przez siebie pliku <strong>transformaty XSL</strong>.</p>

<p>Nie ma w tym większej filozofii, gdyby nie kilka ciekawostek:</p>

<ul>
<li>W sieci jest stosunkowo dużo materiałów i przykładów odnośnie konwersji <strong>XML to HTML</strong>, ale o wiele rzadziej można się natknąć na przydatne informacje odnośnie transformacji <strong>XML to XML</strong>.</li>
<li>W pliku podczas transformacji natrafiłem na potrzebę stworzenia węzła wynikowego, którego nazwa była w postaci wartości w jednym z węzłów źródłowych, zatem nie była znana w momencie pisania pliku XSLT</li>
<li>Podczas iterowania po dzieciach danego węzła musiałem mieć możliwość odczytania ich aktualnego indeksu na liście węzłów-dzieci należących do danego rodzica.</li>
</ul>


<p>Zacznijmy jednak od krótkiej definicji <strong>XSLT</strong>. Jest to prosty język znacznikowy oparty na <strong>XML</strong>. Służy on formowaniu przekształceń (transformat) plików <strong>XML</strong> na inne typy plików (m.in. html, czysty tekst, czy inne pliki xml). Jest to wygodne rozwiązanie, zwłaszcza gdy przychodzi nam do stworzenia strony w htmlu zawierającej dane w postaci xml. <strong>XSLT</strong> służy wtedy wygodnemu tworzeniu wzorca takiej strony.</p>

<p>Poniżej przedstawię parę prostych porad odnośnie tworzenia transformaty dla plików <strong>XML</strong>. Są to w zasadzie podstawy, ale mam nadzieję, że pozwolą zaoszczędzić nieco czasu osobom, które stawiają pierwsze kroki w tej dziedzinie.</p>

<h2>XML to XML</h2>

<p>Pierwszym krokiem powinno być zdefiniowanie w naszej transformacie formatu wyjściowego transformowanych plików. Służy do tego następująca konstrukcja:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&#39;1.0&#39;?&gt;</span>
</span><span class='line'><span class="nt">&lt;xsl:stylesheet</span> <span class="na">version=</span><span class="s">&quot;1.0&quot;</span> <span class="na">xmlns:xsl=</span><span class="s">&quot;http://www.w3.org/1999/XSL/Transform&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;xsl:output</span> <span class="na">method=</span><span class="s">&quot;xml&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;/xsl:stylesheet&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Atrybut method znacznika <code>xsl:output</code> pozwala nam zdefiniować format pliku wyjściowego.</p>

<p>Drugim podstawowym krokiem jest konstrukcja węzła xml. W tym celu posłużymy się znacznikiem <code>xsl:element</code> z atrybutem name. Przykład:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;xsl:element</span> <span class="na">name=</span><span class="s">&quot;pozycja&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;xsl:value-of</span> <span class="na">select=</span><span class="s">&quot;root/position&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/xsl:element&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Powyższy fragment spowoduje stworzenie węzła o nazwie pozycja, mającego za swoją wartość wartość odpowiadającego węzła position, będącego dzieckiem węzła root. Tyle odnośnie podstaw.</p>

<h2>Dynamiczne nazywanie węzłów</h2>

<p>Następną ciekawostką jest wspomniana przeze mnie wcześniej możliwość dynamicznego nazywania węzłów za pomocą wyrażeń <strong><strong>XSLT</strong></strong>. Aby przykład był jaśniejszy, zobrazuję go tak:</p>

<p>Załóżmy, że mamy węzeł <code>pos</code> zawierający wartośc <code>geo1</code>. Chcielibyśmy, aby w wynikowym pliku xml pojawił się węzeł o nazwie <code>pos_geo1</code>, dodatkowo, żeby jego nazwa mogła ulegać zmianie w zależności od wartości przechowywanej w <code>pos</code>. Niestety, wyrażenie <code>value-of</code> tutaj nie zadziała. Na szczęście w xslt istnieje jednak jego odpowiednik, który można stosować do atrybutów węzłów &ndash; chodzi o parę nawiasów <strong>{}</strong>. Są one atrybutowym odpowiednikiem <code>value-of</code>, tzn. doklejają wartość przechowywaną pod wyrażeniem, które znajduje się wewnątrz tych nawiasów jako element stringa w atrybucie. Przykład:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;xsl:element</span> <span class="na">name=</span><span class="s">&quot;pos_{pos}&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="nt">&lt;/xsl:element&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p> W przypadku, kiedy wewnątrz węzła źródłowego znajduje się wartość <code>geo1</code>, powyższy kod spowoduje stworzenie węzła o nazwie <code>pos_geo1</code>.</p>

<h2>Index iterowanego elementu</h2>

<p>Ostatnim przykładem będzie wydobycie numeru indeksu aktualnie iterowanego elementu. Jak wiemy, do iterowania po elementach-dzieciach danego węzła służy konstrukcja <code>xsl:for-each</code>. Jednakże, tak jak pętle foreach znane z normalnych języków programowania, nie posiada ona żadnej (jawnej) wartości inkrementowanej. Skąd więc ją wydobyć? Służy do tego metoda <code>position()</code> , którą zawieramy wewnątrz poznanych wcześniej sześciennych nawiasów <strong>{}</strong>. Należy pamiętać, że w przeciwieństwie do większości języków programowania pierwszy indeks będzie miał numer 1 a nie zero. Przykład:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;xsl:for-each</span> <span class="na">select=</span><span class="s">&quot;kryteria&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;xsl:element</span> <span class="na">name=</span><span class="s">&quot;kryt_{position()-1}&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>        <span class="nt">&lt;xsl:value-of</span> <span class="na">select=</span><span class="s">&quot;kryterium&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/xsl:element&gt;</span>
</span><span class='line'><span class="nt">&lt;/xsl:for-each&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Powyższy przykład spowoduje zamianę seri znacznika <strong>kryteria</strong> z dziećmi <strong>kryterium</strong> na serię znaczników o nazwie <strong>kryt</strong>_nr gdzie nr będzie aktualnym indeksem danego <strong>kryterium</strong> na liście dzieci węzła <strong>kryteria</strong>. Dodatkowo odejmując 1 spowodujemy, że odliczanie numeru nr zacznie się od 0.</p>

<p>To wszystko na dzisiaj. Mam nadzieję, że te informacje trochę pomogą i skrócą wasz czas nauki narzędzia, jakim jest <strong><strong>XSLT</strong></strong>.</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2011-02-25T11:35:00+01:00" data-updated="true" itemprop="datePublished">Feb 25<span>th</span>, 2011</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/algorytmy/'>algorytmy</a>, <a class='category' href='/blog/categories/silverlight/'>silverlight</a>


</div>
		
			<span class="comments"><a href="/blog/2011/02/25/silverlight-detekcja-krawedzi/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2011/02/25/silverlight-detekcja-krawedzi/" itemprop="url">Silverlight - Detekcja Krawędzi</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>W dzisiejszym poście postaram się opisać, w jaki sposób zaimplementować filtr obrazu służący do wykrywania krawędzi. W tym celu posłużymy się implementacją filtru Sobela (jest to jeden z najpopularniejszych filtrów służących temu celowi). Ale po kolei. Najpierw ustalmy plan, według którego będziemy przygotowywać obraz do obróbki:</p>

<ul>
<li>Po pierwsze potrzebna nam będzie klasa umożliwiającą odwołanie się do pojedyńczych pixeli obrazu. W Windows Forms i WPF nie ma z tym większego problemu (możliwe są operacje wskaźnikowe), o tyle tutaj konieczne jest wykorzystanie innej metody. W tym celu posłużymy się klasą <strong>WriteableBitmap</strong>, która jest dostępna od 3 edycji Silverlighta.</li>
<li>Po drugie, nasz obraz wstępnie przetworzymy na inny widoczny w skali szarości. Uprości do budowę filtru przy możliwych do zaakceptowania stratach informacji.</li>
</ul>


<p>Na wstępie warto wspomieć co nieco o samej klasie <strong>WriteableBitmap</strong>. Wybrałem ją, ponieważ udostępnia ona pełną kolekcję pixeli składających się na obraz w postaci prostej właściwości Pixels, zwracającej tablicę typu int. 4 bajty składające się na pixel to kolejno: BGRA. Dzięki temu możemy szybko iterować po kolejnych pixelach obrazu. Jest to wygodne rozwiązanie.</p>

<p>Podczas pisania filtru Sobela przyjąłem, że każdorazowo przekazywana do niego bitmapa będzie zawierała obraz w skali szarości. Pokażę tutaj krótki przykład pętli zamieniającej zakres kolorów:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">bmp</span><span class="p">.</span><span class="n">PixelHeight</span> <span class="p">*</span> <span class="n">bmp</span><span class="p">.</span><span class="n">PixelWidth</span><span class="p">;</span> <span class="p">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">pix</span> <span class="p">=</span> <span class="n">bmp</span><span class="p">.</span><span class="n">Pixels</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>   <span class="kt">var</span> <span class="n">t</span> <span class="p">=</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">(</span><span class="n">pix</span><span class="p">);</span>
</span><span class='line'>   <span class="kt">byte</span> <span class="n">p</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)(</span><span class="n">r</span> <span class="p">*</span> <span class="n">t</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">+</span> <span class="n">g</span> <span class="p">*</span> <span class="n">t</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">+</span> <span class="n">b</span> <span class="p">*</span> <span class="n">t</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">pixel</span> <span class="p">=</span> <span class="n">BitConverter</span><span class="p">.</span><span class="n">ToInt32</span><span class="p">(</span><span class="k">new</span> <span class="kt">byte</span><span class="p">[]</span> <span class="p">{</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="m">255</span> <span class="p">},</span> <span class="m">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>   <span class="n">bmp</span><span class="p">.</span><span class="n">Pixels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">pixel</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Zmienne <code>r</code>, <code>g</code> i <code>b</code> prezentują odpowienio wagi, których używamy w każdej składowej przy obliczaniu odcienia szarości. Ich wartości mogą być różne, dlatego też ich tu nie podaję. Chętni sami zapoznają się z tym tematem.</p>

<p>Teraz pola na implementację samego filtru wykrywania krawędzi. Z dokładniejszym opisem jego działania można zapoznać się <a href="http://en.wikipedia.org/wiki/Sobel_operator">tutaj</a>. Ważną częścią filtru są dwie macierze, które będziemy nakładać na każdy pixel oraz jego otoczenie. Oto jak wygląda ich implementacja:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span><span class="p">[,]</span> <span class="n">_xk</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[,]</span>
</span><span class='line'>                                               <span class="p">{</span>   
</span><span class='line'>              <span class="p">{</span> <span class="p">-</span><span class="m">1</span><span class="p">,</span>  <span class="m">0</span><span class="p">,</span>  <span class="m">1</span> <span class="p">},</span>
</span><span class='line'>              <span class="p">{</span> <span class="p">-</span><span class="m">2</span><span class="p">,</span>  <span class="m">0</span><span class="p">,</span>  <span class="m">2</span> <span class="p">},</span>
</span><span class='line'>              <span class="p">{</span> <span class="p">-</span><span class="m">1</span><span class="p">,</span>  <span class="m">0</span><span class="p">,</span>  <span class="m">1</span> <span class="p">}</span>
</span><span class='line'>                                               <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span><span class="p">[,]</span> <span class="n">_yk</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[,]</span>
</span><span class='line'>                                               <span class="p">{</span>   
</span><span class='line'>              <span class="p">{</span>  <span class="m">1</span><span class="p">,</span>  <span class="m">2</span><span class="p">,</span>  <span class="m">1</span> <span class="p">},</span>
</span><span class='line'>              <span class="p">{</span>  <span class="m">0</span><span class="p">,</span>  <span class="m">0</span><span class="p">,</span>  <span class="m">0</span> <span class="p">},</span>
</span><span class='line'>              <span class="p">{</span> <span class="p">-</span><span class="m">1</span><span class="p">,</span> <span class="p">-</span><span class="m">2</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span> <span class="p">}</span>
</span><span class='line'>                                               <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Mając tak zdefiniowane struktury, wystarczy już tylko stworzyć pętle iterujące po kolumnach i wierszach pixeli. Kod realizujący to zadanie wygląda następująco:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="n">WriteableBitmap</span> <span class="n">output</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WriteableBitmap</span><span class="p">(</span>
</span><span class='line'>   <span class="n">bmp</span><span class="p">.</span><span class="n">PixelWidth</span><span class="p">,</span> <span class="n">bmp</span><span class="p">.</span><span class="n">PixelHeight</span><span class="p">);</span>
</span><span class='line'><span class="kt">byte</span> <span class="n">g</span><span class="p">;</span>
</span><span class='line'><span class="kt">double</span> <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span><span class="p">,</span> <span class="n">max</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">bmp</span><span class="p">.</span><span class="n">PixelHeight</span><span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">++){</span>
</span><span class='line'>   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="n">j</span> <span class="p">&lt;</span> <span class="n">bmp</span><span class="p">.</span><span class="n">PixelWidth</span><span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="n">j</span><span class="p">++){</span>
</span><span class='line'>        <span class="n">gx</span> <span class="p">=</span> <span class="n">gy</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="n">k</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">;</span> <span class="n">k</span><span class="p">++){</span>
</span><span class='line'>              <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="n">l</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">;</span> <span class="n">l</span><span class="p">++){</span>
</span><span class='line'>                   <span class="kt">double</span> <span class="n">pix</span> <span class="p">=</span>
</span><span class='line'>                        <span class="n">BitConverter</span><span class="p">.</span><span class="n">GetBytes</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">bmp</span><span class="p">.</span><span class="n">Pixels</span><span class="p">[(</span><span class="n">i</span><span class="p">+</span><span class="n">k</span><span class="p">)*</span><span class="n">bmp</span><span class="p">.</span><span class="n">PixelWidth</span> <span class="p">+</span> <span class="n">j</span> <span class="p">+</span> <span class="n">l</span><span class="p">])[</span><span class="m">0</span><span class="p">];</span>
</span><span class='line'>                   <span class="n">gx</span> <span class="p">+=</span> <span class="n">pix</span><span class="p">*</span><span class="n">_xk</span><span class="p">[</span><span class="n">k</span><span class="p">+</span><span class="m">1</span><span class="p">,</span> <span class="n">l</span><span class="p">+</span><span class="m">1</span><span class="p">];</span>
</span><span class='line'>                   <span class="n">gy</span> <span class="p">+=</span> <span class="n">pix</span><span class="p">*</span><span class="n">_yk</span><span class="p">[</span><span class="n">k</span><span class="p">+</span><span class="m">1</span><span class="p">,</span> <span class="n">l</span><span class="p">+</span><span class="m">1</span><span class="p">];</span>
</span><span class='line'>              <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">g</span> <span class="p">=</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="n">Min</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">gx</span> <span class="p">*</span> <span class="n">gx</span> <span class="p">+</span> <span class="n">gy</span> <span class="p">*</span> <span class="n">gy</span><span class="p">),</span> <span class="m">255</span><span class="p">);</span>
</span><span class='line'>        <span class="n">output</span><span class="p">.</span><span class="n">Pixels</span><span class="p">[</span><span class="n">bmp</span><span class="p">.</span><span class="n">PixelWidth</span> <span class="p">*</span> <span class="n">i</span> <span class="p">+</span> <span class="n">j</span><span class="p">]</span> <span class="p">=</span>
</span><span class='line'>              <span class="n">BitConverter</span><span class="p">.</span><span class="n">ToInt32</span><span class="p">(</span><span class="k">new</span> <span class="kt">byte</span><span class="p">[]</span> <span class="p">{</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="m">255</span><span class="p">},</span> <span class="m">0</span><span class="p">);</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Jak widać nie iterujemy po wszystkich pixelach, lecz pozostawiamy &ldquo;obramowanie&rdquo; grubości 1 pixela wzdłuż wszystkich boków obrazu. Jest to konieczne, gdyż w przeciwnym razie nie moglibyśmy przyłożyć macierzy X i Y do pixeli brzegowych. Z tego samego powodu potrzebne jest rozróżnienie wierszy i kolumn (mimo że właściwość Pixels udostępnia nam tablicę 1-wymiarową).</p>

<p>Dodatkowe słowo wyjaśnienia &ndash; w tym przykładzie posługuję się <strong>BitConverter</strong>em, aby odczytywać wartości konkretnych składowych pixela oraz składać je w pixel. Jest to rozwiązanie czytelne, dlatego warto je tu przedstawić.</p>

<p>PS: nie badałem szybkości działania tego rozwiązania na dużych obrazach. W moim projekcie posługuję się obrazami uzyskiwanymi z kamerki internetowej 1,2Mpx. W takich warunkach szybkość działania jest absolutnie wystarczająca.</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2011-02-20T13:26:00+01:00" data-updated="true" itemprop="datePublished">Feb 20<span>th</span>, 2011</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/dot-net/'>.net</a>, <a class='category' href='/blog/categories/programowanie/'>programowanie</a>


</div>
		
			<span class="comments"><a href="/blog/2011/02/20/c-class-vs-struct/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2011/02/20/c-class-vs-struct/" itemprop="url">[C#] Class vs. Struct</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Dzisiejszy post dotyczyć będzie podstawowych cech języka C#. Mówię tutaj o różnicach występujących pomiędzy strukturami a standardowymi klasami. Rzecz była wałkowana już wiele razy, jednak tutaj postaram się zgromadzić i uporządkować tyle informacji, ile znalazłem na ten temat.</p>

<p>Zacznijmy więc od różnic:</p>

<ul>
<li>Klasy bazowe &ndash; jak powszechnie wiadomo wszystkie klasy w C# dziedziczą po typie <strong>Object</strong>. Dotyczy to również struktur, jednak w sposób niebezpośredni. Każda struktura dziedziczy po typie <strong>ValueType</strong>. Warto jednak wiedzieć, że sam <strong>ValueType również dziedziczy po typie Object</strong>.</li>
<li>Dziedziczenie &ndash; wszystkie struktury są niejawnie zapieczętowane (<strong>sealed</strong>). Oznacza to, że nie mogą służyć jako klasy bazowe do dziedziczenia. Dodatkowo same nie mogą dziedziczyć po innych typach. Aby to zrozumieć przedstawię zdezasemblowany nagłówek struktury w języku CIL: <code>.class public sealed MyStruct extends [mscorlib]System.ValueType</code>. Możliwy jest również inny skrótowy zapis:<code>.class public sealed value MyStruct</code></li>
<li>Miejsce w pamięci &ndash; klasy tworzone są na zarządzanej stercie (chociaż można na to wpływać). Struktury tworzone są zawsze na stosie. Wynika stąd, że dostęp do struktur jest szybszy, ale jednocześnie nie powinny one być zbyt duże (stąd jedno z ich określeń jako &ldquo;<em>lekkich klas</em>&rdquo;). Taki stan rzeczy niesie za sobą również inną konsekwencję &ndash; struktury (jak wszystkie typy wartościowe) mają czas życia ograniczony zasięgiem, w którym się zajmują tzn. po wyjściu poza zasięg są one natychmiast usuwane z pamięci (nie trzeba ich odśmiecać).</li>
<li>Przekazywanie &ndash; dochodzimy do momentu przekazywania obiektów jako np. parametrów funkcji. Klasy zawsze przekazywane są przez referencję (tzn. podawany jest wskaźnik na adres bloku pamięci, który jest zajmowany przez obiekt) &ndash; tak więc wszelkie zmiany dokonane na parametrze będą zachowane po wyjściu z funkcji. Struktury są typami przekazywanymi przez wartość (tzn. parametr funkcji będzie w istocie <em>głęboką kopią</em> przekazanej struktury), co za tym idzie zmiany dokonywane na strukturze przekazanej jako parametr nie będą odzwierciedlone w orginale. Nie jest to zawsze porządane zachowanie, dlatego czasami warto oznaczać takie parametry za pomocą słów kluczowych <strong>out</strong> (kiedy chcemy zainicjalizować daną strukturę) oraz <strong>ref</strong>(kiedy wiemy, że struktura ta jest już zainicjalizowana).</li>
</ul>


<p>Powstaje jeszcze jedno ciekawe pytanie: co się stanie w sytuacji, kiedy struktura zawierająca w sobie typ referencyjny zostanie przekazana? Co się wtedy stanie z klasą wewnątrz niej. Odpowiedź brzmi: skopiowana zostanie jedynie referencja na obiekt, będziemy więc mieli do czynienia z <em>płytką kopią</em> obiektu, mimo, że przekazana struktura będzie <em>głęboką kopią</em>.
&ndash; Wartość null &ndash; w przeciwieństwie do klas struktury nie mogą przyjmować wartości null. Dlatego dobrym zwyczajem jest stworzenie statycznego getera zwracającego jakiś odpowiednik pustej struktury. Oczywiście wszystkie typy wartościowe mogą zostać opakowane w typie generyczym Nullable<T> i przyjmować jako takie wartość null (w takim wypadku zawartość naszej stuktury znajduje się pod właściwością Value). Czasami jest to rozwiązanie porządane, a na jego korzyść idzie fakt, że typ ten został wyposażony dość przyjazną programiście konstrukcję:&lt;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="n">Nullable</span><span class="p">&lt;</span><span class="n">MyStruct</span><span class="p">&gt;</span> <span class="n">p</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyStruct</span><span class="p">();</span>
</span><span class='line'><span class="c1">//prostszy zapis</span>
</span><span class='line'><span class="n">MyStruct</span><span class="p">?</span> <span class="n">p</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyStruct</span><span class="p">();</span>
</span><span class='line'><span class="c1">//lub</span>
</span><span class='line'><span class="n">MyStruct</span><span class="p">?</span> <span class="n">p</span> <span class="p">=</span> <span class="k">default</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Konstruktory &ndash; struktury zabraniają programiście nadpisywać konstruktor domyślny. Możliwe jest jedynie ustanawianie konstruktorów z parametrami. Ciekawostką jest fakt, że ze struktur można korzystać bezpośrednio po nazwaniu referencji. Jednak wymogiem, który musi być spełniony jest wcześniejsze jawne zainicjalizowanie wszystkich pól składowych struktury. Przykład:
Definicja struktury:</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">struct</span> <span class="nc">MyStruct</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span><span class='line'>  <span class="k">public</span> <span class="k">void</span> <span class="nf">ShowX</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Wykorzystanie:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="n">MyStruct</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'><span class="n">s</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>    <span class="c1">//bez tego dostaniemy błąd kompilatora</span>
</span><span class='line'><span class="n">s</span><span class="p">.</span><span class="n">ShowX</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Inicjalizacja pól &ndash; struktury nie mogą inicjalizować początkowych wartości swoich pól. Wpisanie wewnątrz struktury definicji pola w poniższej postaci spowoduje wyrzucenie błędu przez kompilator: <code>
public int y = 1;</code></li>
<li>Metoda Finalize() &ndash; jak wiadomo klasy wykorzystują tą metodę w momencie, kiedy zachodzi ich odśmiecenie. Każda z nich niebezpośrednio przesłania tą metodę. Jednak nie ma to miejsa w przypadku struktur, gdyż nie są one przechowywane na stercie ani nie podlegają kontroli <strong>Garbage Collectora</strong>.</li>
</ul>


<p>Opowiedzieliśmy już o różnicach, czas na to co jest wspólne dla klas i struktur:
&ndash; Zarówno klasy jak i struktury mogą deklarować zmienne statyczne, publiczne, prywatne (struktury nie mogą zawierać pól o dostępie <em>protected</em>) i jak i internal.
&ndash; Klasy i struktury mogą definiować typy generyczne.
&ndash; Mogą implementować interfejsy (mimo, że struktury nie obsługują dziedziczenia, implementacja interfejsów jest możliwa).
&ndash; Mogą przeciążać operatory i definiować stałe.
&ndash; Mogą definiować właściwości i obsługiwać zdarzenia.</p>

<p>Jak widać różnic jest dość sporo, tyle na plus co i na minus. Struktury w C# znacznie się różnią od swoich odpowiedników w C++. Czasami warto się zastanowić nad ich wykorzystaniem w praktyce, gdyż może to poskutkować szybszym działaniem programu. Sądzę, że z tego powodu nie należy ich zawsze spisywać na straty.</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2011-02-09T20:17:00+01:00" data-updated="true" itemprop="datePublished">Feb 9<span>th</span>, 2011</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/dot-net/'>.net</a>, <a class='category' href='/blog/categories/programowanie/'>programowanie</a>


</div>
		
			<span class="comments"><a href="/blog/2011/02/09/typy-anonimowe-metody/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2011/02/09/typy-anonimowe-metody/" itemprop="url">Typy Anonimowe a Metody</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Witam, w dzisiejszym poście postaram się streścić ideę pomysłu, który jakiś czas temu przyszedł mi do głowy. Rozpatrzmy następujący przypadek:</p>

<p>Załóżmy, że mamy zaimplementowaną relacyjną bazę danych i odwołujemy się do niej wykorzystując mapowania O\R oraz Linq do wydobywania rezultatów zapytań. W środowisku .Net jest to sytuacja dość częsta, okazuje się jednak, że nieraz nie chcemy pobierać wszystkich informacji zawartych w tabelach. W tym celu w zapytaniach Linq często stosuje się tzw. typy anonimowe. Umożliwiają one stworzenie listy obiektów, nie definiując uprzednio typu klasy, jakiego mają być dane obiekty. Jest to bardzo wygodne rozwiązanie, zawiera jednak 2 zasadnicze wady:</p>

<ol>
<li>pola\właściwości zainicjalizowane w ten sposób zawsze są typu readonly</li>
<li>wewnątrz typów anonimowych nie można definiować metod</li>
</ol>


<p>Jak widać jest to spory ubytek w stosunku do np. popularnych klas anonimowych, jakie można spotkać w Javie. W dzisiejszym poście opiszę sposób na okrężne rozwiązanie 2 punktu.</p>

<p>Niech za przykład posłuży nam tabela <strong>users</strong> wypełniona obiektami klasy <strong>Osoba</strong> zawierająca różne pola np.: identyfikator, imie, nazwisko, adres itp. W naszym problemie chcemy jednak ograniczyć się do wyboru 2 pól &ndash; imienia i nazwiska. W tym celu stosujemy typ anonimowy. Cała sytuacja jest opisana poniżej:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="kt">var</span> <span class="n">items</span> <span class="p">=</span> <span class="p">(</span><span class="k">from</span> <span class="n">x</span> <span class="k">in</span> <span class="n">users</span>
</span><span class='line'>      <span class="k">select</span> <span class="k">new</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="n">Name</span> <span class="p">=</span> <span class="n">x</span><span class="p">.</span><span class="n">FirstName</span><span class="p">,</span>
</span><span class='line'>          <span class="n">Surname</span> <span class="p">=</span> <span class="n">x</span><span class="p">.</span><span class="n">LastName</span>
</span><span class='line'>      <span class="p">}).</span><span class="n">ToList</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>Rozwińmy jednak problem. Załóżmy, że chcemy mieć dostęp do metody, która w typ przypadku będzie zwracała stringa wypisującego imię i nazwisko danego użytkownika. Tutaj właśnie dochodzimy do sedna rozwiązania. Ponieważ w typach anonimowych można definiować wyłącznie obiekty. Obejściem jest&hellip; delegat! Wpierw zadeklarujemy delegata (możemy też wykorzystać któregoś z wbudowanych o ile będzie odpowiedni do potrzeb naszej funkcji):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">public</span> <span class="k">delegate</span> <span class="kt">string</span> <span class="nf">StringDelegate</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>Teraz wystarczy już tylko dodać całość do wywołania obiektu typu anonimowego i przekazać np. za pomocą wyrażenia lambda ciało metody do wykonania:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">new</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">Name</span> <span class="p">=</span> <span class="n">x</span><span class="p">.</span><span class="n">FirstName</span><span class="p">,</span>
</span><span class='line'>  <span class="n">Surname</span> <span class="p">=</span> <span class="n">x</span><span class="p">.</span><span class="n">LastName</span><span class="p">,</span>
</span><span class='line'>  <span class="n">FullName</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringDelegate</span><span class="p">(()=&gt;{</span>
</span><span class='line'>      <span class="k">return</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;{0} {1}&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">FirstName</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">LastName</span><span class="p">);</span>
</span><span class='line'>  <span class="p">})</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Całość okazała się prosta do zaimplementowania. Teraz aby wywołać naszą metodę, wystarczy napisać (posługując się kodem napisanym poprzednio) <code>items[0].FullName()</code> :) .</p>

<p>Na koniec rozpatrzmy kilka uwag:</p>

<ul>
<li><p>Należy pamiętać, że mimo wszystko wciąż mamy do czynienia z delegatem, zatem wywołując <i><b>FullName()</b></i> w rzeczywistości dochodzi do wywołania metody <i><b>FullName.Invoke()</b></i>. Nie myślcie więc, że w ten sposób można np. przeciążyć w typie anonimowym metodę ToString(). To rozwiązanie ma na celu przede wszystkim wygodę programisty.</p></li>
<li><p>Jak widzimy na przykładzie, pobranie parametrów w metodzie jest wykonywane z obiektu x. Jest tak ponieważ definiując ciało wyrażenia lambda kompilator nie jest jeszcze w stanie rozpoznać składowych typu anonimowego. Wyrażenie jawne za pomocą this również nie jest możliwe. Możnaby się spytać, co się zatem stanie, gdybyśmy próbowali zmienic zawartość którejś ze składowych typu anonimowego. Odpowiedź jest prosta: nie skompilujemy takiego projektu, ponieważ składowe typów anonimowych są zawsze typu readonly i po zainicjowaniu nie można ich zmieniać :) .</p></li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2011-02-05T10:43:00+01:00" data-updated="true" itemprop="datePublished">Feb 5<span>th</span>, 2011</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/dot-net/'>.net</a>, <a class='category' href='/blog/categories/programowanie/'>programowanie</a>


</div>
		
			<span class="comments"><a href="/blog/2011/02/05/syntaxhighlighter/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2011/02/05/syntaxhighlighter/" itemprop="url">Immutable String - Czy Na Pewno?</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Na wstępie zacznę od przedstawienia łańcuchów znakowych w językach takich jak C# i Java. Jak zapewno większości z czytelników wiadomo, łańcuch znaków jest w tych językach niezmienny tzn. przypisanie lub dodanie nowej wartości do zmiennej typu string (lub String) spowoduje tak naprawdę zaalokowanie nowego fragmentu pamięci i przypisanie jego adresu do zmiennej. Może to być dość uciążliwe w sytuacji, kiedy często chcemy modyfikować dany łańcuch (ciągłe przepisywanie zmiennych jest dość pamięciożerne). Oczywiście są na to sposoby (jak choćby znana klasa StringBuilder).</p>

<p>Co jednak zrobić w sytuacji, kiedy mamy już zainicjowany string, a potrzebujemy często zmieniać jego zawartość. Oczywiście najbardziej oczywistym rozwiązaniem wydaje się konwersja na tablicę znaków (metoda ToCharArray()), ale miło byłoby dokonywać takich zmian bez tworzenia nowych struktur.</p>

<p>Tutaj własnie dochodzimy do alternatywnych możliwości oferowanych przez język C#, a mianowicie możliwości operowania na wskaźnikach. Takie rozwiązanie pozwoli nam dokonywać zmiany w łańcuchu znaków, bez potrzeby kopiowania i alokowania nowych fragmentów pamięci.
Ideę takiego rozwiązania prezentuje poniższy kod:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="n">String</span> <span class="n">mystring</span> <span class="p">=</span> <span class="err">“</span><span class="n">ala</span> <span class="n">ma</span> <span class="n">kota</span><span class="err">”</span><span class="p">;</span>
</span><span class='line'><span class="k">unsafe</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fixed</span> <span class="p">(</span><span class="kt">char</span><span class="p">*</span> <span class="n">mystrptr</span> <span class="p">=</span> <span class="n">mystring</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">mystrptr</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)(*</span><span class="n">mystrptr</span> <span class="p">-</span> <span class="m">32</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">mystring</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Odwołanie za pomocą indexu wykonałem, aby pokazać, że można swobodnie zmieniać pojedyńcze znaki, wypisując po prostu ich pozycję w stringu.
Trudnością takiego rozwiązania jest fakt, że należy w projekcie zezwolić na wykorzystywanie kodu unsafe. Poniżej zamieszczam minitutorial dla osób, które nie wiedzą jak to zrobić:</p>

<ul>
<li>W menu wybieramy zakładkę <strong>Project</strong>&rArr;<strong>Nazwa_projetku</strong>&rArr;<strong>Properties&hellip;</strong></li>
<li>Wyświetla się nam okno z właściwościami projektu, przechodzimy do zakładki <strong>Build</strong> i zaznaczamy pole <strong>Allow unsafe code</strong>.</li>
</ul>


<p>Niestety niektórych rzeczy nie da się przeskoczyć, przykładowo nie możemy wydłużyć istniejącego stringa (jeżeli spróbujemy zmienić znak o indeksie będącym poza zakresem stringa, nie dostaniemy żadnej błędnej wiadomości, ale ostatecznie nadpisany znak i tak nie zostanie wyświetlony). Niemniej sposób który opisałem, jest przyjemną ciekawostką i pozwala nieco nagiąć prawa rządzące łańcuchami znaków w C#.</p>

<h2>Comments</h2>


<div class='comments'>
<div class='comment'>
<div class='author'>Rafał Garbowski</div>
<div class='content'>
Interesujący artykuł, oby było takich więcej ;-)</div>
</div>
</div>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2010-12-11T10:27:00+01:00" data-updated="true" itemprop="datePublished">Dec 11<span>th</span>, 2010</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/dot-net/'>.net</a>, <a class='category' href='/blog/categories/programowanie/'>programowanie</a>


</div>
		
			<span class="comments"><a href="/blog/2010/12/11/podstawy-programowania-w-cil-cz-1/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2010/12/11/podstawy-programowania-w-cil-cz-1/" itemprop="url">Podstawy Programowania W CIL Cz. 1</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Witam, w dzisiejszym poście postaram się pokrótce przedstawić najważniejsze Common Intermediate Language, czyli języka pośredniego platformy .Net. Jak pewnie wszystkim zainteresowanym wiadomo, wszystkie programy napisane w językach platformy .Net są kompilowane wpierw do kodu pośredniego czyli CIL. Jednakże my sami również możemy pisać programy bezpośrednio w nim, a nawet wykorzystywać potem biblioteki z tak napisanym kodem w naszych aplikacjach.</p>

<p>Dlaczego warto poznać CIL? Chociażby dlatego, żeby wiedzieć jak wygląda wewnętrzna realizacja języków wysokiego poziomu. Ale to nie wszystko. Możemy również definiować konstrukcje które nie istnieją lub nie są dostępne w naszych językach wysokiego poziomu (jak np. zmienne globalne, których nie ma w C#).</p>

<p>Zacznijmy od budowy języka. Rolę słów kluczowych w Common Intermediate Language pełnią tzw. tokeny. Możemy je podzielić na 3 grupy:</p>

<ol>
<li><strong>Dyrektywy</strong> &ndash; służą opisowi struktury pakietu. Można je rozpoznać po prefixie &ldquo;.&rdquo; (np. .namespace, .assembly itp.).</li>
<li><strong>Atrybuty</strong> &ndash; służą określaniu, w jaki sposób dana dyrektywa ma zostać przetworzona. Przykładowe atrybuty to: extends, implements, private.</li>
<li><strong>Kody operacyjne</strong> &ndash; odpowiadają za podawanie logiki (można o nich myśleć trochę jak o instrukcjach assemblera). Przykłady: box, unbox, throw. W praktyce nazwy te służą czytelniejszemu rozpoznawaniu binarnych kodów operacyjnych (np. 0X58 (kod add) to kod operacyjny dodawania 2 liczb, zaś 0X73 (kod newobj) służy alokacji obiektu na zarządzanej stercie).</li>
<li><strong>Etykiety</strong> &ndash; służą rozpoznawaniu danej linii kodu. Mogą przyjmować dodowlne nazwy (pod warunkiem, że nie powtarzają się w zasięgu tej samej składowej) i nie są wymagane do prawidłowego działania kodu. Jedyne sytuacje, kiedy są obowiązkowe, to określenie przepływu logiki w konstrukcjach rozgałęzienia lub w pętlach.</li>
</ol>


<p>W CIL zmienne są przechowywane na tzw. wirtualnym stosie wykonywania (virtual execution stack). Aby mieć dostęp do danego elementu, musimy go wpierw jawnie załadować na stos, a potem zrzucić go, kiedy będziemy chccieli go użyć.</p>

<p>Stwórzmy teraz przykładowy projekt &ldquo;Hello World&rdquo; i przeanalizujmy jego kod w języku CIL. W tym celu posłużę się możliwością utworzenia gotowego projektu z rozszerzeniem .il w programie MonoDevelop (niestety VS nie umożliwia jeszcze dodawania projektów pisanych w kodzie pośrednim). Jednakże aby móc podlągać i pisać w VS polecam zapoznać się z programami <strong>ilasm</strong> (kompilator), <strong>ildasm</strong> (dezassembler) oraz <strong>peverify</strong> (program sprawdzający poprawność zbudowanego kodu). Kod wynikowy może się nieco różnić, ale główna idea zostanie bez zmian.</p>

<p>Tak więc po stworzeniu nowego projektu naszym oczom ukazał się następujący kod:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.assembly HelloWorld
</span><span class='line'>{
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>.assembly extern mscorlib { }
</span><span class='line'>
</span><span class='line'>.namespace DefaultNamespace
</span><span class='line'>{
</span><span class='line'>    .class private auto ansi beforefieldinit MainClass extends [mscorlib]System.Object
</span><span class='line'>    {
</span><span class='line'>        .method public hidebysig static void Main(string[] args) cil managed
</span><span class='line'>        {
</span><span class='line'>            .entrypoint
</span><span class='line'>            .maxstack  1
</span><span class='line'>            ldstr "Hello World!"
</span><span class='line'>            call void [mscorlib]System.Console::WriteLine(string)
</span><span class='line'>            ret
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Przejdźmy więc do jego interpretacji</p>

<ul>
<li><code>.assembly HelloWorld</code> &ndash; oznacza to nasz pakiet. Wewnątrz można zaszyć informacje istotne dla pakietu (np. .ver, .module).</li>
<li><code>.assembly extern mscorlib</code> &ndash; deklarujemy pakiety zewnętrzne, z których korzysta nasz pakiet.</li>
<li><code>.class private auto ansi beforefieldinit MainClass </code> &ndash; definicja głównej klasy programu. Atrybut extends oznacza, że nasza klasa dziedziczy po System.Object.</li>
<li><code>.entrypoint </code>&ndash; oznakowuje daną metodę jako punkt wejścia dla pliku wykonywalnego.</li>
<li><code>.maxstack</code> &ndash; określa maksymalną głębokość wirtualnego stosu wykonywania.</li>
<li><code>ldstr</code> &ndash; operacja ładowania stringa na stos.</li>
<li><code>call void [mscorlib]System.Console::WriteLine(string)</code> &ndash; wywołanie metody WriteLine z klasy System.Console. CIL wymaga, aby podawać pełną nazwę kwalifikowaną typu za każdym razem, kiedy chcemy się do niego odwołać. Poza tym musimy podać dokładną definicję metody.</li>
</ul>


<p>Ten przykładowy kod pozwala nam zrozumieć podstawy języka. Ponieważ obiektami, interfejsami i strukturami chcę zająć się w następnym artykule tutaj podam tylko krótką tabelę opisującą bazowe typy danych i odpowiadające im słowa kluczowe CIL. Będą nam potrzebne później.</p>

<table class="table"><tbody><tr><th>Typ klasy bazowej .NET</th><th>Reprezentacja w języku CIL</th><th>Notacja stałych CIL</th>  </tr><tr> <td>System.SByte</td><td>int8</td><td>I1</td> </tr><tr> <td>System.Byte</td><td>unsigned int8</td><td>U1</td> </tr><tr> <td>System.Int16</td><td>int16</td><td>I2</td> </tr><tr> <td>System.Int32</td><td>int32</td><td>I4</td> </tr><tr> <td>System.Int64</td><td>int64</td><td>I8</td> </tr><tr> <td>System.Char</td><td>char</td><td>CHAR</td> </tr><tr> <td>System.Single</td><td>float32</td><td>R4</td> </tr><tr> <td>System.Double</td><td>float64</td><td>R8</td> </tr><tr> <td>System.Boolean</td><td>bool</td><td>BOOLEAN</td> </tr><tr> <td>System.String</td><td>string</td><td>brak</td> </tr><tr> <td>System.Object</td><td>object</td><td>brak</td> </tr><tr> <td>System.Void</td><td>void</td><td>VOID</td> </tr></tbody></table>


<p>To wszystko. W następnym artykule nauczymy się, jak tworzyć własne klasy oraz jak je wykorzystywać w naszym programie.</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2010-11-16T13:32:00+01:00" data-updated="true" itemprop="datePublished">Nov 16<span>th</span>, 2010</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/dot-net/'>.net</a>, <a class='category' href='/blog/categories/algorytmy/'>algorytmy</a>, <a class='category' href='/blog/categories/programowanie/'>programowanie</a>


</div>
		
			<span class="comments"><a href="/blog/2010/11/16/csharp-skompresowane-drzewo-trie/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2010/11/16/csharp-skompresowane-drzewo-trie/" itemprop="url">[CSharp] Skompresowane Drzewo TRIE</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Ostatnimi czasy powróciłem do programów wykonywanych na potrzeby przedmiotów na Informatyce. Wśród nich udało mi się odnaleźć projekt skompresowanego drzewa TRIE. Po drobnym odświeżeniu pomyślałem, że mogę się nim podzielić tutaj.</p>

<p>Czym w zasadzie jest skompresowane drzewo TRIE? Czym różni się tak bardzo od swojej normalnej wersji? Głębiej zainteresowanych tematem odsyłam do wyszukiwania. Najprostszym źródłem jest wikipedia [<a href="http://pl.wikipedia.org/wiki/Skompresowane_drzewo_trie">Link</a>]. Tutaj postaram się skupić na opisaniu podstawowych operacji: dodaniu elementu, usunięciu go, wyszukaniu i odczytaniu klucza.</p>

<p><strong>Odczytanie słowa-klucza dla wybranego węzła</strong> &ndash; tutaj widać pierwszą różnicę w stosunku do standardowego TRIE. Węzeł nie przechowuje całego klucza, a jedynie tę jego część, która jest unikalna dla samego węzła i nie powtarza się w pokrewnych gałęziach. W związku z tym samo odczytanie polega na poruszaniu się w górę drzewa (aż do korzenia) i wrzucaniu na stos kolejnych fragmentów klucza, przechowywanych przez przodków węzła, w którym zaczęliśmy. Następnie wystarczy złączyć ściągane ze stosu elementy &ndash; w ten sposób otrzymujemy gotowy klucz.</p>

<p><strong>Wyszukiwanie węzła wg. podanego wzorca</strong> &ndash; zaczynając od korzenia, musimy sprawdzić wzorzec dla każdego z jego dzieci. W pierwszej kolejności eliminujemy te węzły, których składowa klucza jest dłuższa od wzorca (takie węzły są automatycznie niezgodne). Dla pozostałych wykonujemy porównanie wzorca ze składową szukając momentu, w którym oba ciągi się różnią. Dalej wycinamy z wzorca zgodną część (w tym celu należało zapamiętać numer pozycji, w której wystąpiła różnica) i powtarzamy operację wyszukiwania dla kolejnych dzieci węzła, przekazując im skrócony wzorzec.</p>

<p><strong>Dodawanie węzła</strong> &ndash; tutaj sprawa może być dość skomplikowana. Pierwszy przypadek: Zaczynając od korzenia, dla każdego z jego dzieci należy porównać podany klucz z ich składową klucza. Dla tych, które są częściowo zgodne, skracamy klucz o wspólną część i sprawdzamy dalej. Jeżeli w ten sposób doszliśmy do końca i wszystkie składowe we wszystkich węzłach zostały sprawdzone w całości, po prostu dodajemy kolejny węzeł do dzieci najbardziej podobnego rodzica. W innym wypadku, jeżeli ostatnia składowa klucza jest tylko częściowo podobna, należy wyciąć część wspólną i stworzyć z niej węzeł, do którego dodajemy 2 węzły mające za składowe różniące się między sobą części klucza. Ostatnia sytuacja zachodzi wtedy, gdy klucz okazuje się w pełni zgodny ze składową, ale jest od niej krótszy. Wtedy ponownie wydzielamy część wspólną, ale tym razem węzeł, który był rodzicem, zostaje ustawiony jako dziecko względem nowo stworzonego węzła, który zajmuje jego dotychczasowe miejsce w drzewie.</p>

<p><strong>Usuwanie węzła</strong> &ndash; zaczynając od korzenia, wyszukujemy wzorca wśród jego dzieci. Zakładając, że usuwany węzeł istnieje, wyrzucamy go z drzewa i wracamy do jego rodzica. Jeżeli rodzicowi zostało tylko jedno dziecko, ale sam zawiera pewną wartość, nie robimy nic. Jeżeli jest inaczej usówamy rodzica, zaś na początku składowej klucza jedynaka dodajemy składową rodzica i ustawiamy więzy pokrewienstwa.</p>

<p>Całość opisuje poniższy kod &ndash; klasa PatriciaTreeNode opisuje jedynie operacje na węzłach:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
<span class='line-number'>202</span>
<span class='line-number'>203</span>
<span class='line-number'>204</span>
<span class='line-number'>205</span>
<span class='line-number'>206</span>
<span class='line-number'>207</span>
<span class='line-number'>208</span>
<span class='line-number'>209</span>
<span class='line-number'>210</span>
<span class='line-number'>211</span>
<span class='line-number'>212</span>
<span class='line-number'>213</span>
<span class='line-number'>214</span>
<span class='line-number'>215</span>
<span class='line-number'>216</span>
<span class='line-number'>217</span>
<span class='line-number'>218</span>
<span class='line-number'>219</span>
<span class='line-number'>220</span>
<span class='line-number'>221</span>
<span class='line-number'>222</span>
<span class='line-number'>223</span>
<span class='line-number'>224</span>
<span class='line-number'>225</span>
<span class='line-number'>226</span>
<span class='line-number'>227</span>
<span class='line-number'>228</span>
<span class='line-number'>229</span>
<span class='line-number'>230</span>
<span class='line-number'>231</span>
<span class='line-number'>232</span>
<span class='line-number'>233</span>
<span class='line-number'>234</span>
<span class='line-number'>235</span>
<span class='line-number'>236</span>
<span class='line-number'>237</span>
<span class='line-number'>238</span>
<span class='line-number'>239</span>
<span class='line-number'>240</span>
<span class='line-number'>241</span>
<span class='line-number'>242</span>
<span class='line-number'>243</span>
</pre></td><td class='code'><pre><code class='c#'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="k">class</span>
</span><span class='line'><span class="err">{</span>
</span><span class='line'>   <span class="k">public</span> <span class="kt">string</span> <span class="n">Key</span> <span class="p">{</span> <span class="k">set</span><span class="p">;</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>   <span class="k">public</span> <span class="n">T</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">set</span><span class="p">;</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>   <span class="k">public</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">Nodes</span> <span class="p">{</span> <span class="k">set</span><span class="p">;</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>   <span class="k">public</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Parent</span> <span class="p">{</span> <span class="k">set</span><span class="p">;</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>   <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">getWord</span><span class="p">();</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">private</span> <span class="kt">string</span> <span class="nf">getWord</span><span class="p">()</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="c1">//ponieważ na każdym węźle trzymamy jedynie część całego słowa, aby odczytać cały klucz należy</span>
</span><span class='line'>        <span class="c1">//złączyć wszystkie częściowe klucze na węzłach zaczynając od korzenia</span>
</span><span class='line'>        <span class="n">Stack</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">stack</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">t</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span> <span class="n">t</span> <span class="p">!=</span> <span class="k">null</span><span class="p">;</span> <span class="n">t</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="n">Parent</span><span class="p">)</span>
</span><span class='line'>              <span class="n">stack</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">Key</span><span class="p">);</span>
</span><span class='line'>        <span class="n">StringBuilder</span> <span class="n">sb</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">();</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">Count</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
</span><span class='line'>              <span class="n">sb</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">Pop</span><span class="p">());</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sb</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">public</span> <span class="nf">PatriciaTreeNode</span><span class="p">()</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="n">Value</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>        <span class="n">Key</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>        <span class="n">Nodes</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>        <span class="n">Parent</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">public</span> <span class="nf">PatriciaTreeNode</span><span class="p">(</span><span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">string</span> <span class="n">key</span><span class="p">,</span> <span class="n">T</span> <span class="k">value</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="n">Nodes</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>        <span class="n">Parent</span> <span class="p">=</span> <span class="n">parent</span><span class="p">;</span>
</span><span class='line'>        <span class="n">Key</span> <span class="p">=</span> <span class="n">key</span><span class="p">;</span>
</span><span class='line'>        <span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">Nodes</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>              <span class="n">parent</span><span class="p">.</span><span class="n">Nodes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;();</span>
</span><span class='line'>        <span class="n">parent</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">private</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Replace2</span><span class="p">(</span><span class="kt">string</span> <span class="n">st</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="c1">//stwórz nowy węzeł ze wspólnej części kluczy dwóch węzłów wywoływanych z poprzedniej funkcji</span>
</span><span class='line'>        <span class="c1">//i oznacza index ostatniego znaku w częsci słowa wspólnej dla obu węzłów</span>
</span><span class='line'>        <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span><span class="p">.</span><span class="n">Parent</span><span class="p">,</span> <span class="n">Key</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">Key</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Key</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">//z niewspólnej dla węzłów części klucza stwórz nowy klucz</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">Parent</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>           <span class="c1">//usuń zależność dziecko-rodzic</span>
</span><span class='line'>        <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">SetRelationship</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>   <span class="c1">//ustawiamy relacje ojciec-dziecko</span>
</span><span class='line'>        <span class="c1">//musimy stworzyć nowe dziecko z drugiej niewspólnej części klucza</span>
</span><span class='line'>        <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">newChild</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">node</span><span class="p">,</span> <span class="n">st</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">newChild</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">private</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Replace</span><span class="p">(</span><span class="kt">string</span> <span class="n">st</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="c1">//ta podmiana służy sytuacji, gdy trzeba rozbić jeden węzeł na dwa nowe w relacji rodzic-dziecko,</span>
</span><span class='line'>        <span class="c1">//ponieważ klucz nowego węzła zawiera się w starym</span>
</span><span class='line'>        <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span><span class="p">.</span><span class="n">Parent</span><span class="p">,</span> <span class="n">st</span><span class="p">);</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">Key</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">Key</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">Parent</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="n">Parent</span> <span class="p">=</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>        <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">SetRelationship</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">SetRelationship</span><span class="p">(</span><span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">parent</span><span class="p">,</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">child</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">Nodes</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>              <span class="n">parent</span><span class="p">.</span><span class="n">Nodes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;();</span>
</span><span class='line'>        <span class="n">parent</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
</span><span class='line'>        <span class="n">child</span><span class="p">.</span><span class="n">Parent</span> <span class="p">=</span> <span class="n">parent</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">public</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Add</span><span class="p">(</span><span class="kt">string</span> <span class="n">st</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">st</span> <span class="p">==</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>            <span class="c1">//jeżeli przekazano pusty łańcuch zwracamy null</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Parent</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">Key</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">!=</span> <span class="n">st</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>   <span class="c1">//jeżeli klucz nie ma części wspólnej z st, nie rób nic</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">bool</span> <span class="n">b</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">Nodes</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>              <span class="k">if</span> <span class="p">(</span><span class="n">Parent</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>              <span class="p">{</span>
</span><span class='line'>                   <span class="n">node</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span><span class="p">,</span> <span class="n">st</span><span class="p">);</span>
</span><span class='line'>                   <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>              <span class="p">}</span>
</span><span class='line'>              <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">Length</span> <span class="p">&lt;</span> <span class="n">Key</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span>
</span><span class='line'>              <span class="p">{</span>
</span><span class='line'>                   <span class="k">return</span> <span class="nf">AddChecker</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>
</span><span class='line'>              <span class="p">}</span>
</span><span class='line'>              <span class="k">else</span>  <span class="c1">//jeżeli to wzorzec jest dłuższy</span>
</span><span class='line'>              <span class="p">{</span>
</span><span class='line'>                   <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">Key</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="n">Key</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="n">b</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>                   <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1">//jeżeli wzorzec jest zgodny z kluczem, ale nie jest cały sprawdzony</span>
</span><span class='line'>                   <span class="p">{</span>
</span><span class='line'>                        <span class="n">node</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span><span class="p">,</span> <span class="n">st</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span><span class='line'>                        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>                   <span class="p">}</span>
</span><span class='line'>                   <span class="k">return</span> <span class="nf">Replace2</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'>              <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>    <span class="c1">//jeżeli mają dzieci</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>              <span class="k">if</span> <span class="p">(</span><span class="n">Parent</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>              <span class="p">{</span>
</span><span class='line'>                   <span class="c1">//sprawdzamy czy wzorca nie można dołączyć do któregoś z dzieci</span>
</span><span class='line'>                   <span class="k">foreach</span> <span class="p">(</span><span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">Nodes</span><span class="p">)</span>
</span><span class='line'>                        <span class="k">if</span> <span class="p">((</span><span class="n">node</span> <span class="p">=</span> <span class="n">n</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">st</span><span class="p">))</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>                              <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>                   <span class="n">node</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span><span class="p">,</span> <span class="n">st</span><span class="p">);</span>
</span><span class='line'>                   <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>              <span class="p">}</span>
</span><span class='line'>              <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">Length</span> <span class="p">&lt;</span> <span class="n">Key</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span>
</span><span class='line'>              <span class="p">{</span>
</span><span class='line'>                   <span class="k">return</span> <span class="nf">AddChecker</span><span class="p">(</span><span class="n">st</span><span class="p">);</span>
</span><span class='line'>              <span class="p">}</span>
</span><span class='line'>              <span class="k">else</span>
</span><span class='line'>              <span class="p">{</span>
</span><span class='line'>                   <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">Key</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="n">Key</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="n">b</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>                   <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1">//jeżeli wzorzec jest zgodny z kluczem, ale nie jest cały sprawdzony</span>
</span><span class='line'>                   <span class="p">{</span>
</span><span class='line'>                        <span class="c1">//próbujemy dodać pozostałą część wzorca do któregoś z dzieci</span>
</span><span class='line'>                        <span class="k">foreach</span> <span class="p">(</span><span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">Nodes</span><span class="p">)</span>
</span><span class='line'>                              <span class="k">if</span> <span class="p">((</span><span class="n">node</span> <span class="p">=</span> <span class="n">n</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>                                   <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>                        <span class="c1">//jeżeli żadne dziecko nie przyjęło wzorca, tworzymy nowe dziecko</span>
</span><span class='line'>                        <span class="n">node</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span><span class="p">,</span> <span class="n">st</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span><span class='line'>                        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>                   <span class="p">}</span>
</span><span class='line'>                   <span class="k">return</span> <span class="nf">Replace2</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'>              <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">public</span> <span class="k">static</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Remove</span><span class="p">(</span><span class="kt">string</span> <span class="n">st</span><span class="p">,</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">root</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span> <span class="p">=</span> <span class="n">Search</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>     <span class="c1">//wyszukujemy poszukiwanego słowa</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Nodes</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>              <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Parent</span><span class="p">.</span><span class="n">Parent</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="c1">//jeżeli ojciec jest korzeniem</span>
</span><span class='line'>              <span class="p">{</span>
</span><span class='line'>                   <span class="n">node</span><span class="p">.</span><span class="n">Parent</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span><span class='line'>                   <span class="n">node</span><span class="p">.</span><span class="n">Parent</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>                   <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>              <span class="p">}</span>
</span><span class='line'>              <span class="k">else</span>                                  <span class="c1">//ojciec nie jest korzeniem</span>
</span><span class='line'>              <span class="p">{</span>
</span><span class='line'>                   <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">n</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">Parent</span><span class="p">;</span>
</span><span class='line'>                   <span class="c1">//usuwamy więzy zależności między odnalezionym węzłem i jego ojcem</span>
</span><span class='line'>                   <span class="n">node</span><span class="p">.</span><span class="n">Parent</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>                   <span class="n">n</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span><span class='line'>                   <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">1</span> <span class="p">&amp;&amp;</span> <span class="n">n</span><span class="p">.</span><span class="n">Value</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>     <span class="c1">//jeżeli ojcowi zostało tylko 1 dziecko i sam nie ma żadnej wartości</span>
</span><span class='line'>                   <span class="p">{</span>
</span><span class='line'>                        <span class="c1">//dążymy do sytuacji w której dziecko przejmuje rolę ojca</span>
</span><span class='line'>                        <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">o</span> <span class="p">=</span> <span class="n">n</span><span class="p">.</span><span class="n">Nodes</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>         <span class="c1">//wybieramy dziecko</span>
</span><span class='line'>                        <span class="n">o</span><span class="p">.</span><span class="n">Key</span> <span class="p">=</span> <span class="n">n</span><span class="p">.</span><span class="n">Key</span> <span class="p">+</span> <span class="n">o</span><span class="p">.</span><span class="n">Key</span><span class="p">;</span>                             <span class="c1">//łączymy klucze rodzica i dziecka</span>
</span><span class='line'>                        <span class="n">n</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
</span><span class='line'>                        <span class="n">o</span><span class="p">.</span><span class="n">Parent</span> <span class="p">=</span> <span class="n">n</span><span class="p">.</span><span class="n">Parent</span><span class="p">;</span>
</span><span class='line'>                        <span class="n">n</span><span class="p">.</span><span class="n">Parent</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
</span><span class='line'>                        <span class="n">n</span><span class="p">.</span><span class="n">Parent</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span><span class='line'>                        <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
</span><span class='line'>                   <span class="p">}</span>
</span><span class='line'>                   <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>              <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">Count</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>              <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">o</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">Nodes</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
</span><span class='line'>              <span class="n">o</span><span class="p">.</span><span class="n">Key</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">Key</span> <span class="p">+</span> <span class="n">o</span><span class="p">.</span><span class="n">Key</span><span class="p">;</span>
</span><span class='line'>              <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">SetRelationship</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Parent</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
</span><span class='line'>              <span class="n">node</span><span class="p">.</span><span class="n">Parent</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">Remove</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
</span><span class='line'>              <span class="n">node</span><span class="p">.</span><span class="n">Nodes</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
</span><span class='line'>              <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">private</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">AddChecker</span><span class="p">(</span><span class="kt">string</span> <span class="n">st</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="kt">bool</span> <span class="n">b</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">//sprawdzamy do którego znaku oba słowa są do siebie podobne</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="n">Key</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="n">b</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span>    <span class="c1">//jeżeli wzorzec jest zgodny z kluczem, ale nie cały klucz został sprawdzony</span>
</span><span class='line'>              <span class="k">return</span> <span class="nf">Replace</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">Replace2</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>   <span class="c1">//jeżeli w jakimś miejscu są niezgodne</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">public</span> <span class="k">static</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Search</span><span class="p">(</span><span class="kt">string</span> <span class="n">st</span><span class="p">,</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">main</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">string</span> <span class="n">word</span><span class="p">;</span>                     <span class="c1">//słowo przekazywane do kolejnych funkcji</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">main</span><span class="p">.</span><span class="n">Parent</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>    <span class="c1">//podany węzeł nie jest korzeniem</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>              <span class="k">if</span> <span class="p">((</span><span class="n">st</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="n">main</span><span class="p">.</span><span class="n">Key</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>      <span class="c1">//jeżeli  wzorzec jest krótszy od klucza, zakończ</span>
</span><span class='line'>              <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">main</span><span class="p">.</span><span class="n">Key</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
</span><span class='line'>                   <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="n">main</span><span class="p">.</span><span class="n">Key</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>               <span class="c1">//jeżeli klucz węzła różni się od wzorca, zakończ</span>
</span><span class='line'>              <span class="c1">//jeżeli wszystko się zgadza, a słowa są tej samej długości, zwróć węzeł</span>
</span><span class='line'>              <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">Length</span> <span class="p">==</span> <span class="n">main</span><span class="p">.</span><span class="n">Key</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="k">return</span> <span class="n">main</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">main</span><span class="p">.</span><span class="n">Nodes</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>     <span class="c1">//jeżeli węzeł ma dzieci</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>              <span class="n">word</span> <span class="p">=</span> <span class="n">st</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>   <span class="c1">//przepisz niesprawdzony fragment wzorca</span>
</span><span class='line'>              <span class="c1">//szukamy reszty wzorca wśród dzieci</span>
</span><span class='line'>              <span class="k">foreach</span><span class="p">(</span><span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">main</span><span class="p">.</span><span class="n">Nodes</span><span class="p">)</span>
</span><span class='line'>                   <span class="k">if</span><span class="p">((</span><span class="n">node</span> <span class="p">=</span> <span class="n">Search</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">public</span> <span class="k">static</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">SearchTemplate</span><span class="p">(</span><span class="kt">string</span> <span class="n">st</span><span class="p">,</span> <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">main</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>        <span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">main</span><span class="p">.</span><span class="n">Parent</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>    <span class="c1">//ojciec nie jest korzeniem</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>              <span class="k">if</span> <span class="p">(</span><span class="n">main</span><span class="p">.</span><span class="n">Key</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">!=</span> <span class="n">st</span><span class="p">[</span><span class="m">0</span><span class="p">])</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>              <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>              <span class="kt">bool</span> <span class="n">b</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
</span><span class='line'>              <span class="k">if</span> <span class="p">(</span><span class="n">main</span><span class="p">.</span><span class="n">Key</span><span class="p">.</span><span class="n">Length</span> <span class="p">&gt;</span> <span class="n">st</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span>       <span class="c1">//jeżeli klucz jest dłuższy od słowa</span>
</span><span class='line'>              <span class="p">{</span>
</span><span class='line'>                   <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">st</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="n">main</span><span class="p">.</span><span class="n">Key</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="n">b</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>      <span class="c1">//sprawdzanie zgodności</span>
</span><span class='line'>                   <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="n">main</span><span class="p">;</span>                     <span class="c1">//jeżeli wzorzec był w pełni zgodny z kluczem, zwróć ten węzeł</span>
</span><span class='line'>                   <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>              <span class="p">}</span>
</span><span class='line'>              <span class="k">else</span>  <span class="c1">//jeżeli klucz jest krótszy od wzorca</span>
</span><span class='line'>              <span class="p">{</span>
</span><span class='line'>                   <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">main</span><span class="p">.</span><span class="n">Key</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="n">main</span><span class="p">.</span><span class="n">Key</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="n">b</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>    <span class="c1">//sprawdzanie zgodności</span>
</span><span class='line'>                   <span class="c1">//jeżeli jest zgodny, sprawdź pozostałą część wzorca wśród dzieci</span>
</span><span class='line'>                   <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">{</span>
</span><span class='line'>                        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">==</span> <span class="n">st</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="k">return</span> <span class="n">main</span><span class="p">;</span>  <span class="c1">//jeżeli nie ma czego dalej sprawdzać zwracamy węzeł</span>
</span><span class='line'>                        <span class="k">if</span> <span class="p">(</span><span class="n">main</span><span class="p">.</span><span class="n">Nodes</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>                              <span class="k">foreach</span> <span class="p">(</span><span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">main</span><span class="p">.</span><span class="n">Nodes</span><span class="p">)</span>
</span><span class='line'>                                   <span class="k">if</span> <span class="p">((</span><span class="n">node</span> <span class="p">=</span> <span class="n">SearchTemplate</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">Substring</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>                   <span class="p">}</span>
</span><span class='line'>                   <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>              <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>    <span class="c1">//jeżeli węzeł to korzeń</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>              <span class="k">if</span> <span class="p">(</span><span class="n">main</span><span class="p">.</span><span class="n">Nodes</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>                   <span class="k">foreach</span> <span class="p">(</span><span class="n">PatriciaTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">main</span><span class="p">.</span><span class="n">Nodes</span><span class="p">)</span>
</span><span class='line'>                        <span class="k">if</span> <span class="p">((</span><span class="n">node</span> <span class="p">=</span> <span class="n">SearchTemplate</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Teraz wystarczy tylko dorzucić do tego &ldquo;nakładkę&rdquo; i gotowe.</p>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
        <a href="/blog/page/4/" class="prev">Prev</a>
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2014

    Bartosz Sypytkowski


Design based on: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
</body>
</html>
